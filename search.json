[{"title":"算法基础课基础算法6-1","url":"/basic-algorithm6.1/","content":"最大不相交区间数\n合并果子\n","categories":["算法"],"tags":[]},{"title":"算法基础课基础算法5-2","url":"/basic-algorithm5.2/","content":" 线性DP\n数字三角形\nO(n2)O(n^2)O(n2)\nf[i,j]f[i,j]f[i,j]表示到坐标为[i,j][i,j][i,j]的路径的和最大值\nf[1][1]=a[1][1]f[1][1] = a[1][1]f[1][1]=a[1][1]\n最长上升子序列\n朴素：O(n2)O(n^2)O(n2)\nf[i]f[i]f[i]表示前iii个数中上升子序列长度的最大值\n优化：O(nlogn)O(nlogn)O(nlogn)\n最长公共子序列\n朴素：O(n2)O(n^2)O(n2)\nf[i,j]=max(f[i−1,j],f[i,j−1])f[i,j] = max(f[i-1,j],f[i,j-1])f[i,j]=max(f[i−1,j],f[i,j−1])\n当a[i]==b[j]a[i]==b[j]a[i]==b[j]时,f[i,j]=max(f[i,j],f[i−1,j−1]+1)f[i,j] = max(f[i,j],f[i-1,j-1]+1)f[i,j]=max(f[i,j],f[i−1,j−1]+1)\n优化：O(nlogn)O(nlogn)O(nlogn)\n 区间DP\n石子合并\nf[i,j]f[i,j]f[i,j]表示将第iii堆石子到第jjj堆石子合并成一堆石子的方式的代价最小值/最大值\n 计数类DP\n 数位统计DP\n","categories":["算法"],"tags":[]},{"title":"算法基础课基础算法5-1","url":"/basic-algorithm5.1/","content":" 动态规划\n\n状态表示f[i,j]f[i,j]f[i,j]\n\n集合\n属性（Max，Min，Cnt）\n\n\n状态计算\n\n集合的划分\n\n\n\n 常用模型\n\n背包问题\n线性dp\n区间dp\n计数类dp\n数位统计dp\n状态压缩dp\n树状dp\n\n 背包问题\n给定nnn个物品和容量vvv的背包，每个物品都有体积viv_ivi​和价值wiw_iwi​，求当∑i=1nvi≤v\\sum_{i=1}^{n} v_i \\le v∑i=1n​vi​≤v时最大的www是多少\n 01背包问题\n每个物品只能用0/1次\nf[i,j]=max(f[i−1,j],f[i−1,j−vi]+wi)f[i,j] = max(f[i-1,j],f[i-1,j-v_i]+w_i)f[i,j]=max(f[i−1,j],f[i−1,j−vi​]+wi​)\n01背包问题\n采药\n 完全背包问题\n物品可以无限次使用\nf[i,j]=Max(f[i−1,j−vi×k]+w[i]×k)f[i,j] = Max(f[i-1,j-v_i \\times k]+w[i] \\times k)f[i,j]=Max(f[i−1,j−vi​×k]+w[i]×k)\nk⊆[0,jvi]k \\subseteq [0,\\frac{j}{v_i}]k⊆[0,vi​j​]\n即f[i,j]=Max(f[i−1,j],f[i−1,j−vi]+wi,f[i−1,j−2vi]+2wi,....,f[i−1][j−kvi]+kwi)f[i,j] = Max(f[i-1,j],f[i-1,j-v_i]+w_i,f[i-1,j-2v_i]+2w_i,....,f[i-1][j-kv_i]+kw_i)f[i,j]=Max(f[i−1,j],f[i−1,j−vi​]+wi​,f[i−1,j−2vi​]+2wi​,....,f[i−1][j−kvi​]+kwi​)\nf[i,j−vi]=Max(f[i−1][j−vi],f[i−1][j−2vi]+wi,...,f[i−1][j−kvi]+(k−1)wi)f[i,j-v_i] = Max(f[i-1][j-v_i],f[i-1][j-2v_i]+w_i,...,f[i-1][j-kv_i]+(k-1)w_i)f[i,j−vi​]=Max(f[i−1][j−vi​],f[i−1][j−2vi​]+wi​,...,f[i−1][j−kvi​]+(k−1)wi​)\nf[i][j]f[i][j]f[i][j]的后kkk项等于f[i][j−vi]+wif[i][j-v_i]+w_if[i][j−vi​]+wi​\n得\nf[i,j]=Max(f[i−1,j],f[i,j−vi]+wi)f[i,j] = Max(f[i-1,j],f[i,j-v_i]+w_i)f[i,j]=Max(f[i−1,j],f[i,j−vi​]+wi​)\n完全背包问题\n 多重背包物品\n每个物品的个数不一致\n朴素做法\nf[i,j]=Max(f[i−1,j],f[i−1,j−vi]+wi,f[i−1,j−2vi]+2wi,....,f[i−1][j−kvi]+kwi)f[i,j] = Max(f[i-1,j],f[i-1,j-v_i]+w_i,f[i-1,j-2v_i]+2w_i,....,f[i-1][j-kv_i]+kw_i)f[i,j]=Max(f[i−1,j],f[i−1,j−vi​]+wi​,f[i−1,j−2vi​]+2wi​,....,f[i−1][j−kvi​]+kwi​)\nk⊆[0,si]k \\subseteq [0,s_i]k⊆[0,si​]\n三重循环即可\n多重背包问题1\n优化：二进制优化\nfor(int i=1;i&lt;=n;i++)&#123;\n    int a,b,s;\n    cin>>a>>b>>s;\n    //v w s;\n    int k = 1;\n    while(k&lt;=s)&#123;\n        cnt++;\n        v[cnt] = a*k;\n        w[cnt] = b*k;\n        s-=k;\n        k*=2;\n    &#125;\n    if(s>0)&#123;\n        cnt++;\n        v[cnt] = a*s;\n        w[cnt] = b*s;\n    &#125;\n&#125;\n对物品进行二进制分组，组数为cntcntcnt，转化为01背包问题求解\nn = cnt;\nfor(int i=1;i&lt;=n;i++)&#123;\n    for(int j=0;j&lt;=m;j++)&#123;\n        f[i][j] = f[i-1][j];\n        if(j>=v[i]) f[i][j] = max(f[i][j],f[i-1][j-v[i]]+w[i]);\n    &#125;\n&#125;\ncout&lt;&lt;f[n][m]&lt;&lt;endl;\n多重背包问题2\n 分组背包问题\n有NNN组，每一组只能选其中一种物品\nf[i][j]=Max(f[i−1,j],f[i−1,j−vi,k]+wi,k)f[i][j] = Max(f[i-1,j],f[i-1,j-v_{i,k}]+w_{i,k})f[i][j]=Max(f[i−1,j],f[i−1,j−vi,k​]+wi,k​)\n分组背包问题\n","categories":["算法"],"tags":[]},{"title":"算法基础课基础算法4-3","url":"/basic-algorithm4.3/","content":" 高斯消元\n在O(n3)O(n^3)O(n3)内求解线性方程组\n// a[N][N]是增广矩阵\nint gauss()\n&#123;\n    int c, r;\n    for (c = 0, r = 0; c &lt; n; c ++ )\n    &#123;\n        int t = r;\n        for (int i = r; i &lt; n; i ++ )   // 找到绝对值最大的行\n            if (fabs(a[i][c]) > fabs(a[t][c]))\n                t = i;\n\n        if (fabs(a[t][c]) &lt; eps) continue;\n\n        for (int i = c; i &lt;= n; i ++ ) swap(a[t][i], a[r][i]);      // 将绝对值最大的行换到最顶端\n        for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];      // 将当前行的首位变成1\n        for (int i = r + 1; i &lt; n; i ++ )       // 用当前行将下面所有的列消成0\n            if (fabs(a[i][c]) > eps)\n                for (int j = n; j >= c; j -- )\n                    a[i][j] -= a[r][j] * a[i][c];\n\n        r ++ ;\n    &#125;\n\n    if (r &lt; n)\n    &#123;\n        for (int i = r; i &lt; n; i ++ )\n            if (fabs(a[i][n]) > eps)\n                return 2; // 无解\n        return 1; // 有无穷多组解\n    &#125;\n`\n    for (int i = n - 1; i >= 0; i -- )\n        for (int j = i + 1; j &lt; n; j ++ )\n            a[i][n] -= a[i][j] * a[j][n];\n\n    return 0; // 有唯一解\n&#125;\n 组合数\n 递推法求组合数\nCab=Ca−1b+Ca−1b−1C_{a}^{b} = C_{a-1}^{b} + C_{a-1}^{b-1}Cab​=Ca−1b​+Ca−1b−1​\n// c[a][b] 表示从a个苹果中选b个的方案数\nfor (int i = 0; i &lt; N; i ++ )\n    for (int j = 0; j &lt;= i; j ++ )\n        if (!j) c[i][j] = 1;\n        else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n","categories":["算法"],"tags":[]},{"title":"算法基础课基础算法4-2","url":"/basic-algorithm4.2/","content":" 欧拉函数\nϕ(n)\\phi(n)ϕ(n)：1-n中与n互质的数的个数\nint phi(int x)\n&#123;\n    int res = x;\n    for (int i = 2; i &lt;= x / i; i ++ )\n        if (x % i == 0)\n        &#123;\n            res = res / i * (i - 1);\n            while (x % i == 0) x /= i;\n        &#125;\n    if (x > 1) res = res / x * (x - 1);\n\n    return res;\n&#125;\n 筛法求欧拉函数\nint primes[N], cnt;     // primes[]存储所有素数\nint euler[N];           // 存储每个数的欧拉函数\nbool st[N];         // st[x]存储x是否被筛掉\n\n\nvoid get_eulers(int n)\n&#123;\n    euler[1] = 1;\n    for (int i = 2; i &lt;= n; i ++ )\n    &#123;\n        if (!st[i])\n        &#123;\n            primes[cnt ++ ] = i;\n            euler[i] = i - 1;\n        &#125;\n        for (int j = 0; primes[j] &lt;= n / i; j ++ )\n        &#123;\n            int t = primes[j] * i;\n            st[t] = true;\n            if (i % primes[j] == 0)\n            &#123;\n                euler[t] = euler[i] * primes[j];\n                break;\n            &#125;\n            euler[t] = euler[i] * (primes[j] - 1);\n        &#125;\n    &#125;\n&#125;\n 快速幂\n在O(logk)O(logk)O(logk)时间内求出求出akmodpa^k mod pakmodp\nint qmi(int m, int k, int p)\n&#123;\n    int res = 1 % p, t = m;\n    while (k)\n    &#123;\n        if (k&amp;1) res = res * t % p;\n        t = t * t % p;\n        k >>= 1;\n    &#125;\n    return res;\n&#125;\n 扩展欧几里得算法\n// 求x, y，使得ax + by = gcd(a, b)\nint exgcd(int a, int b, int &amp;x, int &amp;y)\n&#123;\n    if (!b)\n    &#123;\n        x = 1; y = 0;\n        return a;\n    &#125;\n    int d = exgcd(b, a % b, y, x);\n    y -= (a/b) * x;\n    return d;\n&#125;\n 中国剩余定理\n给定一些两两互质的数，求解线性同余方程组\nToBeContinueTo Be ContinueToBeContinue\n","categories":["算法"],"tags":[]},{"title":"算法基础课基础算法4-1","url":"/basic-algorithm4.1/","content":" 质数\n对于大于一的整数，如果只包含一和本身这两个约数，它就是质数（也叫素数）\n 试除法\nO(n)O(\\sqrt n)O(n​)\nbool is_prime(int x)\n&#123;\n    if (x &lt; 2) return false;\n    for (int i = 2; i &lt;= x / i; i ++ )\n        if (x % i == 0)\n            return false;\n    return true;\n&#125;\n 试除法分解质因数\nvoid divide(int x)\n&#123;\n    for (int i = 2; i &lt;= x / i; i ++ )\n        if (x % i == 0)\n        &#123;\n            int s = 0;\n            while (x % i == 0) x /= i, s ++ ;\n            cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; s &lt;&lt; endl;\n        &#125;\n    if (x > 1) cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; 1 &lt;&lt; endl;\n    cout &lt;&lt; endl;\n&#125;\n 朴素筛法求素数\n枚举每一个数，如果它没有被筛，则加入质数集合，并且把它的所有倍数都筛掉\nO(nloglogn)O(nloglogn)O(nloglogn)\nint primes[N], cnt;     // primes[]存储所有素数\nbool st[N];         // st[x]存储x是否被筛掉\n\nvoid get_primes(int n)\n&#123;\n    for (int i = 2; i &lt;= n; i ++ )\n    &#123;\n        if (st[i]) continue;\n        primes[cnt ++ ] = i;\n        for (int j = i + i; j &lt;= n; j += i)\n            st[j] = true;\n    &#125;\n&#125;\n 线性筛法求素数\nint primes[N], cnt;     // primes[]存储所有素数\nbool st[N];         // st[x]存储x是否被筛掉\n\nvoid get_primes(int n)\n&#123;\n    for (int i = 2; i &lt;= n; i ++ )\n    &#123;\n        if (!st[i]) primes[cnt ++ ] = i;\n        for (int j = 0; primes[j] &lt;= n / i; j ++ )\n        &#123;\n            st[primes[j] * i] = true;\n            if (i % primes[j] == 0) break;\n        &#125;\n    &#125;\n&#125;\n 约数\n 试除法求所有约数\nvector&lt;int> get_divisors(int x)\n&#123;\n    vector&lt;int> res;\n    for (int i = 1; i &lt;= x / i; i ++ )\n        if (x % i == 0)\n        &#123;\n            res.push_back(i);\n            if (i != x / i) res.push_back(x / i);\n        &#125;\n    sort(res.begin(), res.end());\n    return res;\n&#125;\n 约数个数和约数之和\n如果 N = p1^c1 * p2^c2 * … *pk^ck\n约数个数： (c1 + 1) * (c2 + 1) * … * (ck + 1)\n约数之和： (p1^0 + p1^1 + … + p1^c1) * … * (pk^0 + pk^1 + … + pk^ck)\n 欧几里得算法求最大公约数\nint gcd(int a, int b)\n&#123;\n    return b ? gcd(b, a % b) : a;\n&#125;\n","categories":["算法"],"tags":[]},{"title":"算法基础课基础算法3-3","url":"/basic-algorithm3.3/","content":" 最小生成树\n Prim算法\n处理稠密图\n朴素Prim算法 O(n2)O(n^2)O(n2)\n类似dijkstra，找出距离集合最短的点，加入集合，更新其他点到集合的距离\nint n;      // n表示点数\nint g[N][N];        // 邻接矩阵，存储所有边\nint dist[N];        // 存储其他点到当前最小生成树的距离\nbool st[N];     // 存储每个点是否已经在生成树中\n\n\n// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和\nint prim()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n\n    int res = 0;\n    for (int i = 0; i &lt; n; i ++ )\n    &#123;\n        int t = -1;\n        for (int j = 1; j &lt;= n; j ++ )\n            if (!st[j] &amp;&amp; (t == -1 || dist[t] > dist[j]))\n                t = j;\n\n        if (i &amp;&amp; dist[t] == INF) return INF;\n\n        if (i) res += dist[t];\n        st[t] = true;\n\n        for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]);\n    &#125;\n\n    return res;\n&#125;\n堆优化Prim O(mlogn)O(mlogn)O(mlogn) （不常用）\n Kruskal算法\nO(mlogm)O(mlogm)O(mlogm) 处理稀疏图\n\n将所有边按照权重排序\n枚举每条边a-&gt;b,权重c （如果ab不联通，则将边ab加入集合中）\n\nint n, m;       // n是点数，m是边数\nint p[N];       // 并查集的父节点数组\n\nstruct Edge     // 存储边\n&#123;\n    int a, b, w;\n\n    bool operator&lt; (const Edge &amp;W)const\n    &#123;\n        return w &lt; W.w;\n    &#125;\n&#125;edges[M];\n\nint find(int x)     // 并查集核心操作\n&#123;\n    if (p[x] != x) p[x] = find(p[x]);\n    return p[x];\n&#125;\n\nint kruskal()\n&#123;\n    sort(edges, edges + m);\n\n    for (int i = 1; i &lt;= n; i ++ ) p[i] = i;    // 初始化并查集\n\n    int res = 0, cnt = 0;\n    for (int i = 0; i &lt; m; i ++ )\n    &#123;\n        int a = edges[i].a, b = edges[i].b, w = edges[i].w;\n\n        a = find(a), b = find(b);\n        if (a != b)     // 如果两个连通块不连通，则将这两个连通块合并\n        &#123;\n            p[a] = b;\n            res += w;\n            cnt ++ ;\n        &#125;\n    &#125;\n\n    if (cnt &lt; n - 1) return INF;\n    return res;\n&#125;\n【模版】最小生成树\n买礼物\n 二分图\n定义：设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图\n一个图是二分图当且仅当图中不含有奇数环\n 染色法\nO(n+m)O(n+m)O(n+m) 判断是否为二分图\nint n;      // n表示点数\nint h[N], e[M], ne[M], idx;     // 邻接表存储图\nint color[N];       // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色\n\n// 参数：u表示当前节点，c表示当前点的颜色\nbool dfs(int u, int c)\n&#123;\n    color[u] = c;\n    for (int i = h[u]; i != -1; i = ne[i])\n    &#123;\n        int j = e[i];\n        if (color[j] == -1)\n        &#123;\n            if (!dfs(j, !c)) return false;\n        &#125;\n        else if (color[j] == c) return false;\n    &#125;\n\n    return true;\n&#125;\n\nbool check()\n&#123;\n    memset(color, -1, sizeof color);\n    bool flag = true;\n    for (int i = 1; i &lt;= n; i ++ )\n        if (color[i] == -1)\n            if (!dfs(i, 0))\n            &#123;\n                flag = false;\n                break;\n            &#125;\n    return flag;\n&#125;\n 匈牙利算法\nO(mn)O(mn)O(mn)，实际运行时间远小于O(mn)O(mn)O(mn)\n实现二分图的最大匹配\nint n1, n2;     // n1表示第一个集合中的点数，n2表示第二个集合中的点数\nint h[N], e[M], ne[M], idx;     // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边\nint match[N];       // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个\nbool st[N];     // 表示第二个集合中的每个点是否已经被遍历过\n\nbool find(int x)\n&#123;\n    for (int i = h[x]; i != -1; i = ne[i])\n    &#123;\n        int j = e[i];\n        if (!st[j])\n        &#123;\n            st[j] = true;\n            if (match[j] == 0 || find(match[j]))\n            &#123;\n                match[j] = x;\n                return true;\n            &#125;\n        &#125;\n    &#125;\n\n    return false;\n&#125;\n\n// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点\nint res = 0;\nfor (int i = 1; i &lt;= n1; i ++ )\n&#123;\n    memset(st, false, sizeof st);\n    if (find(i)) res ++ ;\n&#125;\n","categories":["算法"],"tags":[]},{"title":"算法基础课基础算法3-2","url":"/basic-algorithm3.2/","content":" 最短路\nnnn为点数，mmm为边数\n若mmm与n2n^2n2同一级别为稠密图，与nnn同一级别为稀疏图\n稠密图使用邻接矩阵储存，稀疏图用邻接表储存\n\n单源最短路\n\n所有边权都是正数\n\n朴素dijkstradijkstradijkstra算法 O(n2+m)O(n^2+m)O(n2+m)\n堆优化版dijkstradijkstradijkstra算法  O(mlogn)O(mlogn)O(mlogn)\n\n\n存在负权边\n\nBellman−FordBellman-FordBellman−Ford算法 O(nm)O(nm)O(nm)\nSPFASPFASPFA算法 一般O(m)O(m)O(m)，最坏O(nm)O(nm)O(nm)\n\n\n\n\n多源汇最短路\n\nfloydfloydfloyd算法 O(n3)O(n^3)O(n3)\n\n\n\n 朴素dijkstra算法\n\n\n初始化距离，$dist[1]=0,dist[i]=+\\infty $，st数组：当前已经确定最短路径的点\n\n\n循环每一个点，找到不在st中的最短距离点t，t加入到st中，用t更新其他点的距离\n\n\nint g[N][N];  // 存储每条边\nint dist[N];  // 存储1号点到每个点的最短距离\nbool st[N];   // 存储每个点的最短路是否已经确定\n\n// 求1号点到n号点的最短路，如果不存在则返回-1\nint dijkstra()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n\n    for (int i = 0; i &lt; n - 1; i ++ )\n    &#123;\n        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点\n        for (int j = 1; j &lt;= n; j ++ )\n            if (!st[j] &amp;&amp; (t == -1 || dist[t] > dist[j]))\n                t = j;\n\n        // 用t更新其他点的距离\n        for (int j = 1; j &lt;= n; j ++ )\n            dist[j] = min(dist[j], dist[t] + g[t][j]);\n\n        st[t] = true;\n    &#125;\n\n    if (dist[n] == 0x3f3f3f3f) return -1;\n    return dist[n];\n&#125;\n一般边数m比较多，所以使用邻接矩阵g[a][b]存储\n 堆优化版dijkstra算法\n将寻找距离最小的点的时间复杂度降低\n堆可以使用手写堆或优先队列\ntypedef pair&lt;int, int> PII;\n\nint n;      // 点的数量\nint h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边\nint dist[N];        // 存储所有点到1号点的距离\nbool st[N];     // 存储每个点的最短距离是否已确定\nvoid add(int a, int b, int c)&#123;\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n&#125;\n// 求1号点到n号点的最短距离，如果不存在，则返回-1\nint dijkstra()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n    priority_queue&lt;PII, vector&lt;PII>, greater&lt;PII>> heap;\n    heap.push(&#123;0, 1&#125;);      // first存储距离，second存储节点编号\n\n    while (heap.size())\n    &#123;\n        auto t = heap.top();\n        heap.pop();\n\n        int ver = t.second, distance = t.first;\n\n        if (st[ver]) continue;\n        st[ver] = true;\n\n        for (int i = h[ver]; i != -1; i = ne[i])\n        &#123;\n            int j = e[i];\n            if (dist[j] > distance + w[i])\n            &#123;\n                dist[j] = distance + w[i];\n                heap.push(&#123;dist[j], j&#125;);\n            &#125;\n        &#125;\n    &#125;\n\n    if (dist[n] == 0x3f3f3f3f) return -1;\n    return dist[n];\n&#125;\n Bellman-Ford算法\n迭代n次，每次遍历所有边，对dist[b]进行更新\nint n, m;       // n表示点数，m表示边数\nint dist[N];        // dist[x]存储1到x的最短路距离\n\nstruct Edge     // 边，a表示出点，b表示入点，w表示边的权重\n&#123;\n    int a, b, w;\n&#125;edges[M];\n\n// 求1到n的最短路距离，如果无法从1走到n，则返回-1。\nint bellman_ford()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n\n    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。\n    for (int i = 0; i &lt; n; i ++ )\n    &#123;\n        for (int j = 0; j &lt; m; j ++ )\n        &#123;\n            int a = edges[j].a, b = edges[j].b, w = edges[j].w;\n            if (dist[b] > dist[a] + w)\n                dist[b] = dist[a] + w;\n        &#125;\n    &#125;\n\n    if (dist[n] > 0x3f3f3f3f / 2) return -1;\n    return dist[n];\n&#125;\n//遍历完后满足三角不等式\ndist[b] &lt;= dist[a] + w\n可以用于找负环，时间复杂度比较高\n SPFA算法\n队列优化的Bellman-Ford算法\nint n;      // 总点数\nint h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边\nint dist[N];        // 存储每个点到1号点的最短距离\nbool st[N];     // 存储每个点是否在队列中\n\n// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1\nint spfa()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n\n    queue&lt;int> q;\n    q.push(1);\n    st[1] = true;\n\n    while (q.size())\n    &#123;\n        auto t = q.front();\n        q.pop();\n\n        st[t] = false;\n\n        for (int i = h[t]; i != -1; i = ne[i])\n        &#123;\n            int j = e[i];\n            if (dist[j] > dist[t] + w[i])\n            &#123;\n                dist[j] = dist[t] + w[i];\n                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入\n                &#123;\n                    q.push(j);\n                    st[j] = true;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    if (dist[n] == 0x3f3f3f3f) return -1;\n    return dist[n];\n&#125;\n推荐使用，只要不被卡或者存在负环\n判断负环\n在进行更新dist[j] = dist[t] + w时，同时维护cnt[x] (1号点到x号点经过的边数)\ncnt[x] = cnt[t]+1;\n若某个cnt[x] 大于等于n，则说明存在负环\nint n;      // 总点数\nint h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边\nint dist[N], cnt[N];        // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数\nbool st[N];     // 存储每个点是否在队列中\n\n// 如果存在负环，则返回true，否则返回false。\nbool spfa()\n&#123;\n    // 不需要初始化dist数组\n    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。\n\n    queue&lt;int> q;\n    for (int i = 1; i &lt;= n; i ++ )\n    &#123;\n        q.push(i);\n        st[i] = true;\n    &#125;\n\n    while (q.size())\n    &#123;\n        auto t = q.front();\n        q.pop();\n\n        st[t] = false;\n\n        for (int i = h[t]; i != -1; i = ne[i])\n        &#123;\n            int j = e[i];\n            if (dist[j] > dist[t] + w[i])\n            &#123;\n                dist[j] = dist[t] + w[i];\n                cnt[j] = cnt[t] + 1;\n                if (cnt[j] >= n) return true;       // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环\n                if (!st[j])\n                &#123;\n                    q.push(j);\n                    st[j] = true;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    return false;\n&#125;\n【模版】单源最短路径（弱化版）\n【模版】单源最短路径（标准版）\n Floyd算法\n基于动态规划\n初始化：\n    for (int i = 1; i &lt;= n; i ++ )\n        for (int j = 1; j &lt;= n; j ++ )\n            if (i == j) d[i][j] = 0;\n            else d[i][j] = INF;\n\n// 算法结束后，d[a][b]表示a到b的最短距离\nvoid floyd()\n&#123;\n    for (int k = 1; k &lt;= n; k ++ )\n        for (int i = 1; i &lt;= n; i ++ )\n            for (int j = 1; j &lt;= n; j ++ )\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n&#125;\n【模板】Floyd 算法\n","categories":["算法"],"tags":[]},{"title":"算法基础课基础算法3-1","url":"/basic-algorithm3.1/","content":" DFS与BFS\n\n深度优先搜索（DFS）\n\n用StackStackStack递归，空间O(h)O(h)O(h)，不具有最短性\n题目：全排列、八皇后\n\n宽度优先搜索（BFS）\n\n用QueueQueueQueue，空间O(2h)O(2^h)O(2h)，“最短路”\n题目：迷宫\n回溯、剪枝\n烤鸡\n猫猫和企鹅\n在矩阵中4个方向遍历\nint dx[] = &#123;1,0,-1,0&#125;,y = &#123;0,1,0,-1&#125;;\n防止走相反的方向导致搜索回溯\nif(i ^ 2 == d) continue;\n8个方向遍历\nint dx[8] = &#123;-1, -1, -1, 0, 1, 1, 1, 0&#125;;\nint dy[8] = &#123;-1, 0, 1, 1, 1, 0, -1, -1&#125;;\n防止走相反的方向导致搜索回溯\nif(i ^ 4 == d) continue;\n 树和图的存储\n树是特殊的无环连通图\n有向图a→ba \\to ba→b\n\n\n邻接矩阵 g[a][b]g[a][b]g[a][b]\n\n\n邻接表，用链表储存点iii可以到达的点\n\n\n// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点\nint h[N], e[N], ne[N], idx;\n\n// 添加一条边a->b\nvoid add(int a, int b)\n&#123;\n    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;\n&#125;\n\n// 初始化\nidx = 0;\nmemset(h, -1, sizeof h);\n 树和图的遍历\n时间复杂度O(n+m)O(n+m)O(n+m)，n表示点数，m表示边数\n\n深度优先遍历\n\nint dfs(int u)\n&#123;\n    st[u] = true; // st[u] 表示点u已经被遍历过\n\n    for (int i = h[u]; i != -1; i = ne[i])\n    &#123;\n        int j = e[i];\n        if (!st[j]) dfs(j);\n    &#125;\n&#125;\n\n宽度优先遍历\n\nqueue&lt;int> q;\nst[1] = true; // 表示1号点已经被遍历过\nq.push(1);\n\nwhile (q.size())\n&#123;\n    int t = q.front();\n    q.pop();\n\n    for (int i = h[t]; i != -1; i = ne[i])\n    &#123;\n        int j = e[i];\n        if (!st[j])\n        &#123;\n            st[j] = true; // 表示点j已经被遍历过\n            q.push(j);\n        &#125;\n    &#125;\n&#125;\n 拓扑排序\n时间复杂度O(n+m)O(n+m)O(n+m)，n表示点数，m表示边数\n有向无环图一定可以拓扑排序，序列可能不唯一\n入度、出度：有多少条边指向自己/从自己这里指出去\n\n\n将入度为0的点入队\n\n\n宽搜，枚举队头的所有出边t→jt \\to jt→j，删掉t→jt \\to jt→j，ttt的出度减一\n\n\nbool topsort()\n&#123;\n    int hh = 0, tt = -1;\n\n    // d[i] 存储点i的入度\n    for (int i = 1; i &lt;= n; i ++ )\n        if (!d[i])\n            q[ ++ tt] = i;\n\n    while (hh &lt;= tt)\n    &#123;\n        int t = q[hh ++ ];\n\n        for (int i = h[t]; i != -1; i = ne[i])\n        &#123;\n            int j = e[i];\n            d[j]--;\n            if (d[j] == 0)\n                q[ ++ tt] = j;\n        &#125;\n    &#125;\n\n    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。\n    return tt == n - 1;\n&#125;\n一个有向无环图至少有一个入度为0的点\n","categories":["算法"],"tags":[]},{"title":"算法基础课基础算法2-3","url":"/basic-algorithm2.3/","content":" 哈希表\n 存储结构\nO(1)O(1)O(1)将大范围数映射到小范围值域（离散化是特殊的hash方式）\n\nxmod   rangex\\mod\\ rangexmod range\n处理冲突\n\n\n拉链法\n\n创建一维数组存储所有哈希值，若不同元素对应同一个哈希值，则在该值拉链下来(链表)\nint h[N], e[N], ne[N], idx;\n\n    // 向哈希表中插入一个数\n    void insert(int x)\n    &#123;\n        int k = (x % N + N) % N; //防止(x % N) 是负数\n        e[idx] = x;\n        ne[idx] = h[k];\n        h[k] = idx ++ ;\n    &#125;\n\n    // 在哈希表中查询某个数是否存在\n    bool find(int x)\n    &#123;\n        int k = (x % N + N) % N;\n        for (int i = h[k]; i != -1; i = ne[i])\n            if (e[i] == x)\n                return true;\n\n        return false;\n    &#125;\n\n开放寻址法\n\n只开辟一个一维数组，经验长度为题目范围的2-3倍\n若应该放入的位置已经有元素，则寻找下一个可以存入的位置\nint h[N];\n\n   // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置\n   int find(int x)\n   &#123;\n       int t = (x % N + N) % N;\n       while (h[t] != null &amp;&amp; h[t] != x)\n       &#123;\n           t ++ ;\n           if (t == N) t = 0; //从头查找\n       &#125;\n       return t;\n   &#125;\n其中null=0x3f3f3f3fnull = 0x3f3f3f3fnull=0x3f3f3f3f\n 字符串哈希\n将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低\n小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果\ntypedef unsigned long long ULL;\nULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64\n\n// 初始化\np[0] = 1;\nfor (int i = 1; i &lt;= n; i ++ )\n&#123;\n    h[i] = h[i - 1] * P + str[i]; //前面的值的指数阶都加一，所以要乘以P\n    p[i] = p[i - 1] * P;\n&#125;\n\n// 计算子串 str[l ~ r] 的哈希值\nULL get(int l, int r)\n&#123;\n    return h[r] - h[l - 1] * p[r - l + 1];\n&#125;\n C++ STL\nvector, 变长数组，倍增的思想\n    size()  返回元素个数\n    empty()  返回是否为空\n    clear()  清空\n    front()/back()\n    push_back()/pop_back()\n    begin()/end()\n    []\n    支持比较运算，按字典序\n\npair&lt;int, int>\n    first, 第一个元素\n    second, 第二个元素\n    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）\n\nstring，字符串\n    size()/length()  返回字符串长度\n    empty()\n    clear()\n    substr(起始下标，(子串长度))  返回子串\n    c_str()  返回字符串所在字符数组的起始地址\n\nqueue, 队列\n    size()\n    empty()\n    push()  向队尾插入一个元素\n    front()  返回队头元素\n    back()  返回队尾元素\n    pop()  弹出队头元素\n\npriority_queue, 优先队列，默认是大根堆\n    size()\n    empty()\n    push()  插入一个元素\n    top()  返回堆顶元素\n    pop()  弹出堆顶元素\n    定义成小根堆的方式：priority_queue&lt;int, vector&lt;int>, greater&lt;int>> q;\n\nstack, 栈\n    size()\n    empty()\n    push()  向栈顶插入一个元素\n    top()  返回栈顶元素\n    pop()  弹出栈顶元素\n\ndeque, 双端队列\n    size()\n    empty()\n    clear()\n    front()/back()\n    push_back()/pop_back()\n    push_front()/pop_front()\n    begin()/end()\n    []\n\nset, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列\n    size()\n    empty()\n    clear()\n    begin()/end()\n    ++, -- 返回前驱和后继，时间复杂度 O(logn)\n\n    set/multiset\n        insert()  插入一个数\n        find()  查找一个数\n        count()  返回某一个数的个数\n        erase()\n            (1) 输入是一个数x，删除所有x   O(k + logn)\n            (2) 输入一个迭代器，删除这个迭代器\n        lower_bound()/upper_bound()\n            lower_bound(x)  返回大于等于x的最小的数的迭代器\n            upper_bound(x)  返回大于x的最小的数的迭代器\n    map/multimap\n        insert()  插入的数是一个pair\n        erase()  输入的参数是pair或者迭代器\n        find()\n        []  注意multimap不支持此操作。 时间复杂度是 O(logn)\n        lower_bound()/upper_bound()\n\nunordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表\n    和上面类似，增删改查的时间复杂度是 O(1)\n    不支持 lower_bound()/upper_bound()， 迭代器的++，--\n\nbitset, 圧位\n    bitset&lt;10000> s;\n    ~, &amp;, |, ^\n    >>, &lt;&lt;\n    ==, !=\n    []\n\n    count()  返回有多少个1\n\n    any()  判断是否至少有一个1\n    none()  判断是否全为0\n\n    set()  把所有位置成1\n    set(k, v)  将第k位变成v\n    reset()  把所有位变成0\n    flip()  等价于~\n    flip(k) 把第k位取反\n","categories":["算法"],"tags":[]},{"title":"算法基础课基础算法2-2","url":"/basic-algorithm2.2/","content":" Trie树\n快速存储和查找字符串集合的数据结构\nint son[N][26], cnt[N], idx;\n// 0号点既是根节点，又是空节点\n// son[][]存储树中每个节点的子节点\n// cnt[]存储以每个节点结尾的单词数量\n\n// 插入一个字符串\nvoid insert(char *str)\n&#123;\n    int p = 0;\n    for (int i = 0; str[i]; i ++ )\n    &#123;\n        int u = str[i] - 'a';\n        if (!son[p][u]) son[p][u] = ++ idx;\n        p = son[p][u];\n    &#125;\n    cnt[p] ++ ;\n&#125;\n\n// 查询字符串出现的次数\nint query(char *str)\n&#123;\n    int p = 0;\n    for (int i = 0; str[i]; i ++ )\n    &#123;\n        int u = str[i] - 'a';\n        if (!son[p][u]) return 0;\n        p = son[p][u];\n    &#125;\n    return cnt[p];\n&#125;\n 并查集\n\n将两个集合合并\n询问两个元素是否在一个集合当中\n\n近乎O(1)O(1)O(1)\n基本原理：每一个集合用一棵树表示，树根的编号就是整个集合的编号。每个节点存储它的父节点p[x]p[x]p[x]表示xxx的父节点\n\n如何判断是树根？\n\np[x]=xp[x] = xp[x]=x\n\n如何求xxx的集合编号\n\nwhile(p[x]!=x) x = p[x]\n\n如何合并两个区间\n\n设p[x]为x集合编号，p[y]是y集合编号。p[x]=y\n优化：路径压缩，先搜索一遍，再将节点的父节点直接指向树根\n(1)朴素并查集：\n\n    int p[N]; //存储每个点的祖宗节点\n\n    // 返回x的祖宗节点+路径压缩\n    int find(int x)\n    &#123;\n        if (p[x] != x) p[x] = find(p[x]);\n        return p[x];\n    &#125;\n\n    // 初始化，假定节点编号是1~n\n    for (int i = 1; i &lt;= n; i ++ ) p[i] = i;\n\n    // 合并a和b所在的两个集合：\n    p[find(a)] = find(b);\n\n\n(2)维护size的并查集：\n\n    int p[N], size[N];\n    //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量\n\n    // 返回x的祖宗节点\n    int find(int x)\n    &#123;\n        if (p[x] != x) p[x] = find(p[x]);\n        return p[x];\n    &#125;\n\n    // 初始化，假定节点编号是1~n\n    for (int i = 1; i &lt;= n; i ++ )\n    &#123;\n        p[i] = i;\n        size[i] = 1;\n    &#125;\n\n    // 合并a和b所在的两个集合：\n    size[find(b)] += size[find(a)];\n    p[find(a)] = find(b);\n\n\n(3)维护到祖宗节点距离的并查集：\n\n    int p[N], d[N];\n    //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离\n\n    // 返回x的祖宗节点\n    int find(int x)\n    &#123;\n        if (p[x] != x)\n        &#123;\n            int u = find(p[x]);\n            d[x] += d[p[x]];\n            p[x] = u;\n        &#125;\n        return p[x];\n    &#125;\n\n    // 初始化，假定节点编号是1~n\n    for (int i = 1; i &lt;= n; i ++ )\n    &#123;\n        p[i] = i;\n        d[i] = 0;\n    &#125;\n\n    // 合并a和b所在的两个集合：\n    p[find(a)] = find(b);\n    d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量\n【模版】并查集\n并查集题单\n 堆\n如何手写一个堆？\n\n插入一个数\n求集合中的最小值\n删除最小值\n删除任意一个元素\n修改任意一个元素\n\nSTL自带堆没有实现\n是一个完全二叉树\n小根堆：根小于等于左右孩子的值\n存储：一维数组，对于iii，左孩子2i2i2i，右孩子2i+12i+12i+1\n借助down(x)down(x)down(x) 与 up(x)up(x)up(x)函数实现上述五种操作\nheap[++size] = x;up(size);\nheap[1]\nheap[1] = heap[size];size--;down(1);\nheap[k] = heap[size];size--;down(k);up(k);\nheap[k] = x;down[k];up[k]\n\n// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1\n// ph[k]存储第k个插入的点在堆中的位置\n// hp[k]存储堆中下标是k的点是第几个插入的\nint h[N], ph[N], hp[N], size;\n\n// 交换两个点，及其映射关系\nvoid heap_swap(int a, int b)\n&#123;\n    swap(ph[hp[a]],ph[hp[b]]);\n    swap(hp[a], hp[b]);\n    swap(h[a], h[b]);\n&#125;\n\nvoid down(int u)\n&#123;\n    int t = u;\n    if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;\n    if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;\n    if (u != t)\n    &#123;\n        heap_swap(u, t);\n        down(t);\n    &#125;\n&#125;\n\nvoid up(int u)\n&#123;\n    while (u / 2 &amp;&amp; h[u] &lt; h[u / 2])\n    &#123;\n        heap_swap(u, u / 2);\n        u >>= 1; //   u/=2\n    &#125;\n&#125;\n\n// O(n)建堆\nfor (int i = n / 2; i; i -- ) down(i);\n包含映射的堆不常用，在dijkstra算法中应用\n","categories":["算法"],"tags":[]},{"title":"Vue学习","url":"/vue/","content":" 代码风格\nVue2：选项式API\nVue3：组合式API\n 准备工作\n首先配置Node.jsNode.jsNode.js环境，然后\nnpm init vue@latest\n初始化名称namenamename（不要用大写字母）\n一路勾选NONONO\nIDE使用VSCodeVSCodeVSCode+VolarVolarVolar插件\n进入namenamename文件夹cd name\n执行npm install\nnpm run dev即可运行项目\n 文件目录\nnode_modules 依赖文件夹\npublic 资源文件夹\nsrc 源码文件夹\nindex.html 入口HTML文件\npackage.json 信息描述文件\nvite.config.js Vue配置文件\n 模版语法\n\n文本插值\n\n​\t&#123;&#123;msg&#125;&#125;，其中可以使用JavaScrpitJavaScrpitJavaScrpit表达式\n​\t&#123;&#123;number +1&#125;&#125; 、&#123;&#123;ok ? 'Yes' : 'No'&#125;&#125;、&#123;&#123;msg.split('')&#125;&#125;\n\n原始html\n\n​\t使用v-html\n 属性绑定\nv-bind\n文本的绑定使用&#123;&#123;&#125;&#125;绑定，而属性（id、class等）的绑定使用v-bind\n&lt;div v-bind:id&#x3D;&quot;ID&quot; v-bind:class&#x3D;&quot;MyClass&quot;&gt;\n    &#123;&#123;msg&#125;&#125;\n&lt;&#x2F;div&gt;\n其中ID、MyClass、msg都是data变量\n简写：:属性\n例如\n&lt;div :id&#x3D;&quot;ID&quot; :class&#x3D;&quot;MyClass&quot;&gt;\n    &#123;&#123;msg&#125;&#125;\n&lt;&#x2F;div&gt;\n将属性存进同一个对象可以实现一次性绑定多个值\n 条件渲染\nv-if v-else v-else-if v-show\nv-if:如果初次渲染时为false，就不会被渲染，有较高的切换开销\nv-show:无论初始值如何都会被渲染，后续根据CSS的display属性切换，有较高的初始渲染开销\n如果需要频繁切换，用v-show\n 列表渲染\nv-for指令基于item in items\n如果要获取下标，使用(item,index) in items\n对于对象数组，则是(value,key,index)\n 通过key管理状态\nVue默认按照“就地更新”，重新渲染消耗性能\n不推荐Key绑定index，而是绑定id等唯一索引属性\n 事件处理\n使用v-on或者@监听DOM事件\n\n内联事件处理器：内联JS语句\n方法事件处理器：指向方法\n\n 事件参数\n在方法中传递参数到事件中\nadd(count)&#123;\n\tthis.num +&#x3D; count;\n&#125;\n传递$event获取JS的event对象\n 事件修饰符\n简化代码\n文档\n&lt;!-- 阻止单击事件继续传播 --&gt;\n&lt;a v-on:click.stop&#x3D;&quot;doThis&quot;&gt;&lt;&#x2F;a&gt;\n\n&lt;!-- 提交事件不再重载页面 --&gt;\n&lt;form v-on:submit.prevent&#x3D;&quot;onSubmit&quot;&gt;&lt;&#x2F;form&gt;\n\n&lt;!-- 修饰符可以串联 --&gt;\n&lt;a v-on:click.stop.prevent&#x3D;&quot;doThat&quot;&gt;&lt;&#x2F;a&gt;\n\n&lt;!-- 只有修饰符 --&gt;\n&lt;form v-on:submit.prevent&gt;&lt;&#x2F;form&gt;\n\n&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;\n&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;\n&lt;div v-on:click.capture&#x3D;&quot;doThis&quot;&gt;...&lt;&#x2F;div&gt;\n\n&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;\n&lt;!-- 即事件不是从内部元素触发的 --&gt;\n&lt;div v-on:click.self&#x3D;&quot;doThat&quot;&gt;...&lt;&#x2F;div&gt;\n 数组变化侦测\n\n变更方法\n\nUI发生更新，原数组发生改变更新\npush()、pop()、shift()、unshift()、sort()、reverse()\n\n替换一个数组\n\nUI不发生更新，赋值到的是新数组\nconcat()、filter()、slice()\n 计算属性\n描述依赖响应式状态的复杂逻辑\ncomputed，方法中进行计算属性\n具有缓存，所以性能优于常规方法调用\n Class绑定\nvue中对于class的v-bind得到加强，表达式除了字符串以外，还可以是数组或者对象\n&#x2F;&#x2F;template:\n&lt;p :class&#x3D;&quot;classObject&quot;&gt;\n    Class样式绑定\n&lt;&#x2F;p&gt;\n\n&#x2F;&#x2F;data:\nclassObject&#123;\n\tactive: true,\n\tdanger: false\n&#125;\n\n&#x2F;&#x2F;style:\n.active&#123;\n\tfont-size:30px\n&#125;\n.danger&#123;\n\tcolor:red\n&#125;\n Style绑定\nvue中对于style的v-bind得到加强，表达式除了字符串以外，还可以是数组或者对象\n&#x2F;&#x2F;template:\n&lt;p :style:&quot;styleObject&quot;&gt;\n    Style样式绑定\n&lt;&#x2F;p&gt;\n\n&#x2F;&#x2F;data:\nstyleObject&#123;\n\tactiveColor: red,\n\tactiveSize: 30\n&#125;\n 侦听器\n使用watch选项在每次响应式属性发生变化时触发一个函数\n&#x2F;&#x2F;data:\nmessage: &quot;Hello&quot;\n\n&#x2F;&#x2F;watch:\nmessage(newValue,oldValue)&#123;\n\t&#x2F;&#x2F;数据发生变化，自动执行方法\n\tconsole.log(&quot;new&#x3D;&gt;&quot;+newValue);\n\tconsole.log(&quot;old&#x3D;&gt;&quot;+oldValue);\n&#125;\n注意watch的方法名必须和data中数据变量名一致\n 表单输入绑定\nv-model\n将表单输入和响应式属性进行双向绑定\n提供修饰符.lazy .number .trim，对输入进行过滤\n.lazy 失去焦点才绑定\n.number 只接受数字\n.trim 去除前后空格\n 模版引用\n一般来说\n内容改变： \n属性改变： v-bind: 指令\n事件： v-on:click\n若要访问一些底层的DOM元素，可以使用ref\n&lt;div ref:&quot;container&quot;&gt;\n    &#123;&#123; content &#125;&#125;\n&lt;&#x2F;div&gt;\n\nthis.$refs.container.属性\n如果没有特殊需求，不要使用ref，比较消耗性能\n 组件组成\n组件的最大优势就是可复用性\n定义在.vue文件中\n组件构成：template,script,style\n引用：\n\n在script中import\n在component中注入组件\n在template以标签形式显示组件\n\n对于一个组件，必须存在template，其他可以没有\nstyle中scoped属性表示：让当前样式只在当前组件中生效\n 组件嵌套关系\nnull\n 组件注册方式\n全局注册和局部注册\n全局注册\n在main.js中，\nimport Header from &quot;.....&quot;;\nconst app &#x3D; createApp(App);\n&#x2F;&#x2F;在这个中间\napp.component(&quot;Header&quot;,Header)\n\napp.mount(&quot;#app&quot;)\n局部注册\n\nimport\n在components中注册\n在template中显示\n\n推荐使用局部注册\n 组件传递数据-Props\n使用props进行组件之间的数据传递\n&lt;Child title&#x3D;&quot;数据&quot;&#x2F;&gt;\n在Child.vue中\nprops:[&quot;title&quot;]\n即可获取title的数据值&#123;&#123;title&#125;&#125;\n也可以结合v-bind，即\n&lt;Child :title&#x3D;&quot;message&quot;&#x2F;&gt;\n\ndata():\n\tmessage: xxx\n注意事项：props传递数据只能从父级到子级，不能反其道而行。\n 组件传递多种数据类型\n此外，props还能传递除了字符串以外的数据类型，例如数字，数组，对象等\n 组件传递Props效验\nprops&#123;\n\ttitle&#123;\n\t\ttype: String,\n\t\tdefault: &quot;Alex&quot;\n\t&#125;\n\tnames&#123;\n\t\ttype: [String,Number,Array,Object],\n\t\trequired: true &#x2F;&#x2F;是否为必选项\n\t&#125;\n&#125;\n如果是数组或者对象，default就需要以函数形式写出来\nnames&#123;\n\ttype:Array,\n\tdefault()&#123;\n\t\treturn xxx;\n\t&#125;\n&#125;\nProps是只读的，不允许进行修改父元素传递过来的数据\n 组件事件\n$emit触发自定义事件，达到组件之间的数据传递\n在子级元素中this.$emit(“someEvent”,data)\n即可在父元素中\n&lt;Child @someEvent&#x3D;&quot;getData&quot; &#x2F;&gt;\n\nmethods:\ngetData(data)&#123;\n\tconsole.log(data);\n&#125;\n父传子：props\n子传父：$emit\n 组件事件配合v-model\n在侦听器watch中进行$emit传递v-model数据的newValue\n 组件数据传递\n用props实现子传父\n将传递的数据类型设置为Function\n 透传Attribute\n×\n 插槽Slots\n为子组件传递一些模版片段，在子组件中渲染这些片段\nApp.vue中\n&lt;template&gt;\n\t&lt;SlotA&gt;\n    \t&lt;h3&gt;\n        hhhh\n    \t&lt;&#x2F;h3&gt;\n    &lt;&#x2F;SlotA&gt;\n&lt;&#x2F;template&gt;\n在SlotA.vue中\n&lt;template&gt;\n\t&lt;h3&gt;\n        原本内容\n    &lt;&#x2F;h3&gt;\n\t&lt;slot&gt;&lt;&#x2F;slot&gt;\n&lt;&#x2F;template&gt;\n在子组件中用slot渲染传入的模版片段\n\n\n插槽内容可以访问到父组件的数据域\n\n\n在没有传递插槽内容情况下，可以设置插槽的默认内容\n\n\n具名插槽：\n\n\n在插槽中设定\n&lt;template v-slot&#x3D;&quot;header&quot;&gt;\n\n&lt;&#x2F;template&gt;\n&lt;template v-slot&#x3D;&quot;main&quot;&gt;\n\n&lt;&#x2F;template&gt;\n即可设定\n&lt;slot name&#x3D;&quot;main&quot;&gt;&lt;&#x2F;slot&gt;\n选定具体需要的内容\n其中v-slot可以简写为#\n 组件生命周期\n创建期，挂载期，更新期，销毁期\nbeforeCreate 组件创建之前\ncreated 组件创建之后\nbeforeMount 组件渲染之前\nmounted 组件渲染之后\nbeforeUpdate 组件更新之前\nupdated 组件更新之后\nbeforeUnmount 组件销毁之前\nunmounted 组件销毁之后\n 生命周期应用\n\n通过ref获取DOM结构\n\nmounted\n\n模拟网络请求渲染数据\n\ncreated,推荐mounted\n 动态组件\n&lt;component :is&#x3D;&quot;ComponentData&quot;&gt;&lt;&#x2F;component&gt;\n 组件保持存活\n使用动态组件切换组件时，被切换的组件会被卸载。使用&lt;keep-alive&gt;强制使组件保持存活\n&lt;keep-alive&gt;\n\t&lt;component :is&#x3D;&quot;ComponentData&quot;&gt;&lt;&#x2F;component&gt;\n&lt;&#x2F;keep-alive&gt;\n保持存活，不会被卸载 ，数据不会被重新初始化\n 异步组件\n&lt;script&gt;\n    import defineAsyncComponent from &#39;vue&#39;\n    const ComponentB &#x3D; defineAsyncComponent(()&#x3D;&gt;&#123;\n        import(&quot;&#x2F;ComponentB.vue&quot;)\n    &#125;)\n&lt;&#x2F;script&gt;\n 依赖注入\nprops逐级透传可以用provide和inject解决\n上级组件\nprovide&#123;\n\tmsg: &quot;123&quot;\n&#125;\n&#x2F;&#x2F;或者\nprovide()&#123;\n\treturn&#123;\n        message &#x3D; this.message\n        &#x2F;&#x2F;获取data中数据\n\t&#125;\n&#125;\n子级组件\ninject:[&quot;msg&quot;]\n即可获取msg内容&#123;&#123;msg&#125;&#125;\n只能由上到下，不能反向传递\n可以在main.js提供全局数据\napp.provide(&quot;global&quot;,&quot;123&quot;)\n Vue应用\n 应用实例\n每一个vue应用都是通过createApp函数创建\nimport &#123;createApp&#125; from &#39;vue&#39;\nconst app &#x3D; createApp(&#123;\n\t&#x2F;&#x2F;根组件选项\n&#125;)\n一个Vue项目中，有且只有一个Vue实例对象\n 根组件\nimport App from &#39;.&#x2F;App.vue&#39;\nconst app &#x3D; createApp(App);\n 挂载应用\n应用实例调用了.mount()才能渲染出来，该方法接受一个容器参数\napp.mount(&#39;#app&#39;)\n&lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;\n 公共资源\n位于.assets下存放公共资源，包括css文件，图片，字体等\n","categories":["前端"],"tags":[]},{"title":"算法基础课基础算法2-1","url":"/basic-algorithm2.1/","content":" 算法基础课基础算法2-1\n 链表与邻接表\n由于用结构体+指针比较慢，一般在面试题使用，在这里使用数组模拟链表\n\n单链表\n\ne[N]：储存链表结点的值\nne[N]：储存结点的下一个结点下标，其中空结点下标为-1\n// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点\nint head, e[N], ne[N], idx;\n\n// 初始化\nvoid init()\n&#123;\n    head = -1;\n    idx = 0;\n&#125;\n\n// 在链表头插入一个数a\nvoid insert(int a)\n&#123;\n    e[idx] = a, ne[idx] = head, head = idx ++ ;\n&#125;\n\n//在a插到下标是k的结点后面\nvoid insert(int a,int k)\n&#123;\n    e[idx] = a, ne[idx] = ne[k], ne[k] = idx ++ ;\n&#125;\n\n// 将头结点删除，需要保证头结点存在\nvoid remove()\n&#123;\n    head = ne[head];\n&#125;\n\n// 将下标为k的结点的后一个点删除\nvoid remove(k)\n&#123;\n    ne[k] = ne[ne[k]];\n&#125;\n\n双链表\n\n作用：优化某些问题\n// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点\nint e[N], l[N], r[N], idx;\n\n// 初始化\nvoid init()\n&#123;\n    //0是左端点，1是右端点\n    r[0] = 1, l[1] = 0;\n    idx = 2;\n&#125;\n\n// 在节点a的右边插入一个数x\nvoid insert(int a, int x)\n&#123;\n    e[idx] = x;\n    l[idx] = a, r[idx] = r[a];\n    l[r[a]] = idx, r[a] = idx ++ ;\n&#125;\n\n// 删除节点a\nvoid remove(int a)\n&#123;\n    l[r[a]] = l[a];\n    r[l[a]] = r[a];\n&#125;\n\n邻接表\n\nN个单链表，用于存储树和图\n 栈\n先进后出(FILO)\n// tt表示栈顶\nint stk[N], tt = 0;\n\n// 向栈顶插入一个数\nstk[ ++ tt] = x;\n\n// 从栈顶弹出一个数\ntt -- ;\n\n// 栈顶的值\nstk[tt];\n\n// 判断栈是否为空，如果 tt > 0，则表示不为空\nif (tt > 0)\n&#123;\n\tnot empty\n&#125;else\n&#123;\n    empty\n&#125;\n 队列\n先进先出(FIFO)\n// hh 表示队头，tt表示队尾\nint q[N], hh = 0, tt = -1;\n\n// 向队尾插入一个数\nq[ ++ tt] = x;\n\n// 从队头弹出一个数\nhh ++ ;\n\n// 队头的值\nq[hh];\n\n// 判断队列是否为空，如果 hh &lt;= tt，则表示不为空\nif (hh &lt;= tt)\n&#123;\n\n&#125;\n循环队列\n// hh 表示队头，tt表示队尾的后一个位置\nint q[N], hh = 0, tt = 0;\n\n// 向队尾插入一个数\nq[tt ++ ] = x;\nif (tt == N) tt = 0;\n\n// 从队头弹出一个数\nhh ++ ;\nif (hh == N) hh = 0;\n\n// 队头的值\nq[hh];\n\n// 判断队列是否为空，如果hh != tt，则表示不为空\nif (hh != tt)\n&#123;\n\n&#125;\n 单调栈\n题型：求给定序列每一个数左/右边离他最近的比他大/小的数\nint tt = 0;\nfor (int i = 1; i &lt;= n; i ++ )\n&#123;\n    while (tt &amp;&amp; check(stk[tt], i)) tt -- ;\n    stk[ ++ tt] = i;\n&#125;\n 单调队列\n题型：求滑动窗口的最大/小值\nint hh = 0, tt = -1;\nfor (int i = 0; i &lt; n; i ++ )\n&#123;\n    while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口\n    while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ;\n    q[ ++ tt] = i;\n&#125;\n KMP\n对于字符串sss,判断是否包含模式串ttt\n// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度\n//求模式串的Next数组：\nfor (int i = 2, j = 0; i &lt;= m; i ++ )\n&#123;\n    while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j];\n    if (p[i] == p[j + 1]) j ++ ;\n    ne[i] = j;\n&#125;\n\n// 匹配\nfor (int i = 1, j = 0; i &lt;= n; i ++ )\n&#123;\n    while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j];\n    if (s[i] == p[j + 1]) j ++ ;\n    if (j == m)\n    &#123;\n        j = ne[j];\n        // 匹配成功后的逻辑\n    &#125;\n&#125;\n","categories":["算法"],"tags":[]},{"title":"2023年中闲聊","url":"/2023%E5%B9%B4%E4%B8%AD%E9%97%B2%E8%81%8A/","content":"现在是2023年6月30日\n环境工程的期末考陆陆续续已经考完了，秉承不挂就行的心态\n这学期参加的两个比赛（ACM校内选拔赛+ACM软件外包创新赛）都以失败告终\n还是自己太菜了\n暑假的计划是 考研数据结构 + ACwing算法基础课，准备混一些奖项牌子\n噶油！\n","categories":["闲聊"],"tags":[]},{"title":"算法基础课基础算法1-3","url":"/basic-algorithm1.3/","content":" 算法基础课基础算法1-3\n 双指针算法\n\n两个序列，两个指针\n一个序列，两个指针\n\n结构\nfor(int i=0,j=0;i&lt;n;i++)&#123;\n    while(j&lt;i &amp;&amp; check(i,j)) j++;\n    //每道题具体的逻辑\n&#125;\n核心思想\n复杂度由O(n2)O(n^2)O(n2)优化到O(n)O(n)O(n)\n先想出朴素做法，寻找i与j之间的关系，进行双指针优化\n 位运算\n\nn的二进制表示中第k位数字是几\n\n（k从个位开始算0,1,2…）\n\n先把第k位移到最后一位n&gt;&gt;k\n看个位是几 x&amp;1\n\n​\tn&gt;&gt;k&amp;1\n\nlowbit(x)\n\n​\t树状数组基本操作，返回x的最后一位1\n​\tx&amp;(-x)\n​\t原理：-x=(~x+1)\n 离散化\n这里特指整数离散化\n将值域大，个数少的数组映射到0,1…n的自然数\n①数组中可能有重复元素，需要去重\n②如何求出xxx离散化后的值-&gt;二分\nC++模版\nvector&lt;int> alls; // 存储所有待离散化的值\nsort(alls.begin(), alls.end()); // 将所有值排序\nalls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素\n\n// 二分求出x对应的离散化的值\nint find(int x) // 找到第一个大于等于x的位置\n&#123;\n    int l = 0, r = alls.size() - 1;\n    while (l &lt; r)\n    &#123;\n        int mid = l + r >> 1;\n        if (alls[mid] >= x) r = mid;\n        else l = mid + 1;\n    &#125;\n    return r + 1; // 映射到1, 2, ...n\n&#125;\n由于Java中没有uniqueuniqueunique方法，其中排序与去重的具体实现如下\n// 去重 + 排序  \nList&lt;Integer> distinctSorterAlls = alls.stream().distinct().sorted()  .collect(Collectors.toList());  \n 区间合并\n\n\n按照区间左端点排序\n\n\n判断下一个区间与当前区间的关系\n\n相交\n\n更新右端点为两个区间的maxmaxmax\n\n\n不相交\n\n将当前区间更新为不相交的这个区间\n\n\n\n\n\n​\tC++模版\n// 将所有存在交集的区间合并\nvoid merge(vector&lt;PII> &amp;segs)\n&#123;\n    vector&lt;PII> res;\n\n    sort(segs.begin(), segs.end());\n\n    int st = -2e9, ed = -2e9;\n    for (auto seg : segs)\n        if (ed &lt; seg.first)\n        &#123;\n            if (st != -2e9) res.push_back(&#123;st, ed&#125;);\n            st = seg.first, ed = seg.second;\n        &#125;\n        else ed = max(ed, seg.second);\n\n    if (st != -2e9) res.push_back(&#123;st, ed&#125;);\n\n    segs = res;\n&#125;\n在Java中可以自定义类来实现PIIPIIPII\nclass Pair&lt;U, V> &#123;\n    public final U first;\n    public final V second;\n\n    private Pair(U first, V second) &#123;\n        this.first = first;\n        this.second = second;\n    &#125;\n\n    @Override\n    public boolean equals(Object o) &#123;\n        if (this == o) &#123;\n            return true;\n        &#125;\n\n        if (o == null || getClass() != o.getClass()) &#123;\n            return false;\n        &#125;\n\n        Pair&lt;?, ?> pair = (Pair&lt;?, ?>) o;\n\n        if (!first.equals(pair.first)) &#123;\n            return false;\n        &#125;\n        return second.equals(pair.second);\n    &#125;\n\n    @Override\n    public int hashCode() &#123;\n        return 31 * first.hashCode() + second.hashCode();\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return \"(\" + first + \", \" + second + \")\";\n    &#125;\n\n    public static &lt;U, V> Pair &lt;U, V> of(U a, V b) &#123;\n        return new Pair&lt;>(a, b);\n    &#125;\n&#125;\n也可以直接用int[]，用前两位数&#123;first,second&#125;代替PIIPIIPII\n","categories":["算法"],"tags":[]},{"title":"算法基础课基础算法1-2","url":"/basic-algorithm1.2/","content":" 算法基础课基础算法1-2\n 高精度运算\nJavaJavaJava中使用BigIntegerBigIntegerBigInteger和BigDecimalBigDecimalBigDecimal类实现\nC++C++C++模版\n\n高精度加法\n\n// C = A + B, A >= 0, B >= 0\nvector&lt;int> add(vector&lt;int> &amp;A, vector&lt;int> &amp;B)\n&#123;\n    if (A.size() &lt; B.size()) return add(B, A);\n\n    vector&lt;int> C;\n    int t = 0;\n    for (int i = 0; i &lt; A.size(); i ++ )\n    &#123;\n        t += A[i];\n        if (i &lt; B.size()) t += B[i];\n        C.push_back(t % 10);\n        t /= 10;\n    &#125;\n\n    if (t) C.push_back(t);\n    return C;\n&#125;\n\n高精度减法\n\n// C = A - B, 满足A >= B, A >= 0, B >= 0\nvector&lt;int> sub(vector&lt;int> &amp;A, vector&lt;int> &amp;B)\n&#123;\n    vector&lt;int> C;\n    for (int i = 0, t = 0; i &lt; A.size(); i ++ )\n    &#123;\n        t = A[i] - t;\n        if (i &lt; B.size()) t -= B[i];\n        C.push_back((t + 10) % 10);\n        if (t &lt; 0) t = 1;\n        else t = 0;\n    &#125;\n\n    while (C.size() > 1 &amp;&amp; C.back() == 0) C.pop_back();\n    return C;\n&#125;\n\n高精度乘低精度\n\n// C = A * b, A >= 0, b >= 0\nvector&lt;int> mul(vector&lt;int> &amp;A, int b)\n&#123;\n    vector&lt;int> C;\n\n    int t = 0;\n    for (int i = 0; i &lt; A.size() || t; i ++ )\n    &#123;\n        if (i &lt; A.size()) t += A[i] * b;\n        C.push_back(t % 10);\n        t /= 10;\n    &#125;\n\n    while (C.size() > 1 &amp;&amp; C.back() == 0) C.pop_back();\n\n    return C;\n&#125;\n\n高精度除以低精度\n\n// A / b = C ... r, A >= 0, b > 0\nvector&lt;int> div(vector&lt;int> &amp;A, int b, int &amp;r)\n&#123;\n    vector&lt;int> C;\n    r = 0;\n    for (int i = A.size() - 1; i >= 0; i -- )\n    &#123;\n        r = r * 10 + A[i];\n        C.push_back(r / b);\n        r %= b;\n    &#125;\n    reverse(C.begin(), C.end());\n    while (C.size() > 1 &amp;&amp; C.back() == 0) C.pop_back();\n    return C;\n&#125;\n\n高精度乘以高精度\n\ncin>>a1>>b1;\n   int lena=strlen(a1);\nint lenb=strlen(b1);\n   for(i=1;i&lt;=lena;i++)a[i]=a1[lena-i]-'0';\n   for(i=1;i&lt;=lenb;i++)b[i]=b1[lenb-i]-'0';\nfor(i=1;i&lt;=lenb;i++)\n\tfor(j=1;j&lt;=lena;j++)\n\t\tc[i+j-1]+=a[j]*b[i];\n   for(i=1;i&lt;lena+lenb;i++)\n\tif(c[i]>9)\n\t&#123;\n\t\tc[i+1]+=c[i]/10;\n\t\tc[i]%=10;\n\t&#125;\nlen=lena+lenb;\n   while(c[len]==0&amp;&amp;len>1)len--;\nA+B Problem(高精)\nA*B Problem(高精)\n 前缀和与差分\n一对逆运算\n 一维前缀和\n设有一列数据a1,a2,...,an−1,an{a}_1,{a}_2,...,{a}_{n-1},{a}_na1​,a2​,...,an−1​,an​\n定义Si=a1+a2+...+ai{S}_i=a_1+a_2+...+a_iSi​=a1​+a2​+...+ai​\n一般下标从1开始，S0=0S_0=0S0​=0\nSiS_iSi​的初始化: Si=Si−1+aiS_i = S_{i-1}+a_iSi​=Si−1​+ai​\n作用\n快速地求出原数组中一段区间数的和\n对于区间[l,r][l,r][l,r]\n∑i=lrai=Sr−Sl−1\\sum_{i=l}^{r}a_i  = S_r-S_{l-1}∑i=lr​ai​=Sr​−Sl−1​\n 二维前缀和\n对于二维数组（矩阵）(a11a12...a1ja21a22...a2j............ai1ai2...aij)\\begin{pmatrix}\n  a_{11}&amp; a_{12} &amp; ... &amp; a_{1j}\\\\\n  a_{21}&amp; a_{22} &amp; ... &amp; a_{2j} \\\\\n  ...&amp; ... &amp; ... &amp; ...\\\\\n  a_{i1}&amp; a_{i2} &amp; ... &amp; a_{ij}\n\\end{pmatrix}⎝⎜⎜⎜⎛​a11​a21​...ai1​​a12​a22​...ai2​​............​a1j​a2j​...aij​​⎠⎟⎟⎟⎞​\nSijS_{ij}Sij​代表aija_{ij}aij​左上角的所有元素和\n\n\n对于点(i,j)(i,j)(i,j)，其二维前缀和SijS_{ij}Sij​的初始化\nSij=Si−1,j+Si,j−1−Si−1,j−1+ai,jS_{ij}=S_{i-1,j}+S_{i,j-1}-S_{i-1,j-1}+a_{i,j}Sij​=Si−1,j​+Si,j−1​−Si−1,j−1​+ai,j​\n\n\n设点(x1,y1)(x_1,y_1)(x1​,y1​)在(x2,y2)(x_2,y_2)(x2​,y2​)的左上角，则两点围成的矩形中所有元素和\nS=Sx2,y2−Sx2,y1−1−Sx1−1,y2+Sx1−1,y1−1S=S_{x_2,y_2}-S_{x_2,y_1-1}-S_{x_1-1,y_2}+S_{x_1-1,y_1-1}S=Sx2​,y2​​−Sx2​,y1​−1​−Sx1​−1,y2​​+Sx1​−1,y1​−1​\n\n\n 一维差分\n对一列数据a1,a2,a3,...,aia_1,a_2,a_3,...,a_ia1​,a2​,a3​,...,ai​\n构造b1,b2,b3,...,bib_1,b_2,b_3,...,b_ib1​,b2​,b3​,...,bi​使得ai=b1+b2+...+bia_i=b_1+b_2+...+b_iai​=b1​+b2​+...+bi​\n即aaa为bbb的前缀和，bbb就是aaa的差分\n{b1=a1b2=a2−a1b3=a3−a2......bn=an−an−1\\left\\{\\begin{matrix}\nb_1=a_1\\\\\nb_2=a_2-a_1\\\\\nb_3=a_3-a_2\\\\\n ......\\\\\nb_n=a_n-a_{n-1}\n\\end{matrix}\\right.⎩⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎧​b1​=a1​b2​=a2​−a1​b3​=a3​−a2​......bn​=an​−an−1​​\n作用\n若要把a1,a2,a3,...,aia_1,a_2,a_3,...,a_ia1​,a2​,a3​,...,ai​中[l,r][l,r][l,r]区间的aaa加ccc\n只需要使bl+=c,br+1−=cb_l+=c,b_{r+1}-=cbl​+=c,br+1​−=c\n模版\nimport java.util.Scanner;\n\npublic class Diff &#123;\n    public static void main(String[] args) &#123;\n\n        Scanner scanner = new Scanner(System.in);\n\n        // 给出n数组大小和k增加次数\n        int n = scanner.nextInt();\n        int k = scanner.nextInt();\n\n        // 搭建数组\n        int[] arr = new int[n+1];\n        int[] brr = new int[n+1];\n\n        // 为arr赋值\n        for (int i = 1; i &lt; n+1; i++) &#123;\n            arr[i] = scanner.nextInt();\n        &#125;\n\n        // 为brr赋值\n        for (int i = 1; i &lt; n+1; i++)&#123;\n            brr[i] = arr[i] - arr[i-1];\n        &#125;\n\n        while (k-- > 0)&#123;\n            // 我们为arr的[l,r]区间加上c\n            int l = scanner.nextInt();\n            int r = scanner.nextInt();\n            int c = scanner.nextInt();\n\n            brr[l] += c;\n            brr[r+1] -= c;\n        &#125;\n\n        // 计算输出结果即可（这里输出的需要是由b累计出来的a）\n        // 也可以使用注释代码，最后输出arr即可\n        for (int i = 1; i &lt; n+1; i++) &#123;\n            brr[i] += brr[i-1];\n            //arr[i] = brr[i]+arr[i-1];\n        &#125;\n\n        // 最后输出结果\n        for (int i = 1; i &lt; n+1; i++) &#123;\n            System.out.println(brr[i]);\n        &#125;\n\n    &#125;\n&#125;\n 二维差分\n原矩阵aija_{ij}aij​,差分矩阵bijb_{ij}bij​\nbx1,y1+=cb_{x1,y1}+=cbx1,y1​+=c\nbx2+1,y−=cb_{x2+1,y}-=cbx2+1,y​−=c\nbx1,y2+1−=cb_{x1,y2+1}-=cbx1,y2+1​−=c\nbx2+1,y2+1+=cb_{x2+1,y2+1}+=cbx2+1,y2+1​+=c\n","categories":["算法"],"tags":[]},{"title":"算法基础课基础算法1-1","url":"/basic-algorithm1.1/","content":" 算法基础课基础算法1-1\n 快速排序\n分治思想,时间复杂度$O(nlogn)-O(n^2) $\n期望时间复杂度O(nlogn)O(nlogn)O(nlogn)\n\n\n数组中找一个值xxx作为分界点（可以是arr[l]arr\\left [ l \\right ]arr[l] ,arr[r]arr\\left [ r \\right ]arr[r],arr[l+r2]arr\\left [ \\frac{l+r}{2} \\right ]arr[2l+r​] 等等…）\n\n\n调整区间，使得左边的区间所有数≤\\le≤x，右边区间所有数&gt;&gt;&gt;x\n\n定义两个指针分别在左右边界\niii不断右移，直到遇到arr[i]arr[i]arr[i] &gt;x&gt;x&gt;x，就停下\njjj不断左移，直到遇到arr[j]≤xarr[j]\\le xarr[j]≤x，就停下\n交换arr[i]arr[i]arr[i]与arr[j]arr[j]arr[j]\n\n\n\n递归处理左右区间\n\n\n模版\npublic static void quick_sort(int q[], int l, int r)&#123;\n    if (l >= r) return;\n    int i = l - 1, j = r + 1, x = q[l + r >> 1];\n    while (i &lt; j)&#123;\n        do i ++ ; while (q[i] &lt; x);\n        do j -- ; while (q[j] > x);\n        if (i &lt; j) &#123;\n            int t = q[i];\n            q[i] = q[j];\n            q[j] = t;           \n        &#125;\n    &#125;\n    quick_sort(q, l, j);\n    quick_sort(q, j + 1, r);\n&#125;\n 归并排序\n分治思想,O(nlogn)O(nlogn)O(nlogn)\n\n\n确定分界点 mid=l+r2mid = \\frac{l+r}{2}mid=2l+r​\n\n\n递归排序leftleftleft和rightrightright\n\n\n归并：合二为一\n\n双指针指向leftleftleft和rightrightright的第一个元素\n创建一个空数组resresres存放结果\n指针比较，如果left[i]&lt;right[j]left[i]&lt;right[j]left[i]&lt;right[j]，则把left[i]left[i]left[i]放入resresres，iii向后移动一位，继续比较\n如果left[i]=right[j]left[i]=right[j]left[i]=right[j]，则把left[i]left[i]left[i]放入resresres，以维持稳定\n\n\n\n模版\npublic static void merge_sort(int q[], int l, int r)&#123;\n    if (l >= r) return;\n    int mid = l + r >> 1;\n\n    merge_sort(q, l, mid);\n    merge_sort(q, mid + 1, r);\n\n    int k = 0, i = l, j = mid + 1;\n\n    while (i &lt;= mid &amp;&amp; j &lt;= r)\n        if (q[i] &lt; q[j]) tmp[k ++ ] = q[i ++ ];\n    else tmp[k ++ ] = q[j ++ ];\n\n    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];\n    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];\n\n    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];\n&#125;\n 整数二分\n提示信息\n\n题目保证有解\n单调性\n求最大值的最小化\n\n思路\n对于区间[l,r][l,r][l,r]，其中一部分满足条件check(x)=truecheck(x)=truecheck(x)=true，另一部分不满足\n\n对于寻找不满足区间的边界\n\nmid=l+r+12mid = \\frac{l+r+1}{2}mid=2l+r+1​\n若check(mid)=truecheck(mid)=truecheck(mid)=true 则说明边界值在[mid,r][mid,r][mid,r]\n更新语句为l=midl = midl=mid\n若check(mid)=falsecheck(mid)=falsecheck(mid)=false 则说明边界值在[l,mid−1][l,mid-1][l,mid−1]\n更新语句为r=mid−1r = mid-1r=mid−1\n\n对于寻找满足区间的边界\n\nmid=l+r2mid = \\frac{l+r}{2}mid=2l+r​\n若check(mid)=truecheck(mid)=truecheck(mid)=true 则说明边界值在[l,mid][l,mid][l,mid]\n更新语句为r=midr = midr=mid\n若check(mid)=falsecheck(mid)=falsecheck(mid)=false 则说明边界值在[mid+1,r][mid+1,r][mid+1,r]\n更新语句为l=mid+1l=mid+1l=mid+1\n模版\npublic static boolean check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质\n\n// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：\npublic static int bsearch_1(int l, int r)\n&#123;\n    while (l &lt; r)\n    &#123;\n        int mid = l + r >> 1;\n        if (check(mid)) r = mid;    // check()判断mid是否满足性质\n        else l = mid + 1;\n    &#125;\n    return l;\n&#125;\n// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：\npublic static int bsearch_2(int l, int r)\n&#123;\n    while (l &lt; r)\n    &#123;\n        int mid = l + r + 1 >> 1;\n        if (check(mid)) l = mid;\n        else r = mid - 1;\n    &#125;\n    return l;\n&#125;\n如果l=midl=midl=mid ，最开始的midmidmid就要补上+1+1+1\n题目参考\n冶炼金属\n垦天计划\n 浮点数二分\npublic static boolean check(double x) &#123;/* ... */&#125; // 检查x是否满足某种性质\n\ndouble bsearch_3(double l, double r)\n&#123;\n    final double eps = 1e-6;   \n    // eps 表示精度，取决于题目对精度的要求\n    //比需要保留的位数多2\n    while (r - l > eps)\n    &#123;\n        double mid = (l + r) / 2;\n        if (check(mid)) r = mid;\n        else l = mid;\n    &#125;\n    return l;\n&#125;\n精度比需要保留的位数多-2次方\n可以把whilewhilewhile循环直接换成for100次\n","categories":["算法"],"tags":[]},{"title":"Git与github的基本使用","url":"/github/","content":"本文建立在读者已经拥有Github账号，本地安装了Git以及绑定了SSH密钥的情况下\n 基本使用\n\n首先在Github上新建一个仓库(Create a new repository)\n\n\n\n仓库名\n仓库的描述\n仓库类型，个人向一般都是public\n协议\n\n此外还可以选择是否添加README文件和.gitignore文件\n前者可以描述项目的主要内容，后者用于对文件的过滤\n至此，一个远程的仓库就创建好了\n\n实现本地代码和仓库代码同步\n\n当你创建好仓库后，你可以选择下面的方式进行代码托管\n\n在本地初始化git仓库后，绑定远程仓库\n\n首先我在桌面上创建一个demo文件夹，里面有一个hhh.txt文件\n在目录下执行git init操作\n\n此时文件夹多出了一个**.git**隐藏文件夹\n推荐常使用git status命令查看仓库状态\n此时我们执行这个命令\n\n大概的意思是，在master分支下，没有文件可以提交；此外还提醒我们hhh.txt文件没有上传\n此时我们执行git add hhh.txt\n如果接下来没有结果，那么恭喜你\n\n没有结果就是最好的结果\n\n此时再使用git status查看状态\n发现hhh.txt “to be committed” ，也就是这个文件已经放在了缓存区（防止你手滑上传了一些文件），你需要再次确认是否上传这个文件\n于是我们输入git commit hhh.txt -m &quot;第一次提交&quot;\n你可能会好奇 “-m” 和后面的**“第一次提交”**是个啥\n如果你有观摩过一些开源项目，会注意到这个\n\n也就是“更新说明”，你可以在commit的时候携带信息，说明这次更新的主要内容\n\n于是乎，文件hhh.txt就上传成功了\n接下来就是需要绑定远程仓库\n输入git remote add origin 仓库地址\n\n没有结果就是最好的结果\n然后我们将我们的文件push到远程仓库\ngit push -u origin 分支名\n\n打开我们的远程仓库，可以看见\n\n至此，这就是最基本的git使用。这是第一种方式\n\nclone到本地进行push\n\n获取到你的远程仓库地址\n\n输入git clone 仓库地址 可能会花费一点时间\n\n此时你clone的文件夹里面就会出现这个项目\n进入项目文件夹，添加文件xxx.txt\n你可以发现这个文件夹自带.git目录，所以你不需要去初始化和绑定远程仓库\ngit add xxx.txt\ngit commit xxx.txt -m &quot;嘻嘻嘻&quot;\ngit push origin [分支]  \n即可\n 在IDEA中使用git\n创建一个IDEA项目（我这里创建Springboot），勾选create git repository\n\n\nIDEA中可以一键进行commit/push操作\n\n绑定远程仓库地址\n\n进行push\n\n完成\n\n","categories":[],"tags":[]},{"title":"HelloWorld","url":"/HelloWorld/","content":"把原来的一些杂乱的学习笔记都删了\n因为我觉得博客应该是记录一些自己的想法，而不是生抄别人的博客或者代码\n\n测试一下图片\npublic class Main&#123;\n    public static void init()&#123;\n        return;\n    &#125;\n&#125;\n测试一下代码块\n咕咕咕\n","categories":["闲聊"],"tags":[]}]