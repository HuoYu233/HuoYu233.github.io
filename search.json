[{"title":"算法基础课基础算法2-1","url":"/basic-algorithm2.1/","content":" 算法基础课基础算法2-1\n 链表与邻接表\n由于用结构体+指针比较慢，一般在面试题使用，在这里使用数组模拟链表\n\n单链表\n\ne[N]：储存链表结点的值\nne[N]：储存结点的下一个结点下标，其中空结点下标为-1\n// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点\nint head, e[N], ne[N], idx;\n\n// 初始化\nvoid init()\n&#123;\n    head = -1;\n    idx = 0;\n&#125;\n\n// 在链表头插入一个数a\nvoid insert(int a)\n&#123;\n    e[idx] = a, ne[idx] = head, head = idx ++ ;\n&#125;\n\n//在a插到下标是k的结点后面\nvoid insert(int a,int k)\n&#123;\n    e[idx] = a, ne[idx] = ne[k], ne[k] = idx ++ ;\n&#125;\n\n// 将头结点删除，需要保证头结点存在\nvoid remove()\n&#123;\n    head = ne[head];\n&#125;\n\n// 将下标为k的结点的后一个点删除\nvoid remove(k)\n&#123;\n    ne[k] = ne[ne[k]];\n&#125;\n\n双链表\n\n作用：优化某些问题\n// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点\nint e[N], l[N], r[N], idx;\n\n// 初始化\nvoid init()\n&#123;\n    //0是左端点，1是右端点\n    r[0] = 1, l[1] = 0;\n    idx = 2;\n&#125;\n\n// 在节点a的右边插入一个数x\nvoid insert(int a, int x)\n&#123;\n    e[idx] = x;\n    l[idx] = a, r[idx] = r[a];\n    l[r[a]] = idx, r[a] = idx ++ ;\n&#125;\n\n// 删除节点a\nvoid remove(int a)\n&#123;\n    l[r[a]] = l[a];\n    r[l[a]] = r[a];\n&#125;\n\n邻接表\n\nN个单链表，用于存储树和图\n 栈\n先进后出(FILO)\n// tt表示栈顶\nint stk[N], tt = 0;\n\n// 向栈顶插入一个数\nstk[ ++ tt] = x;\n\n// 从栈顶弹出一个数\ntt -- ;\n\n// 栈顶的值\nstk[tt];\n\n// 判断栈是否为空，如果 tt > 0，则表示不为空\nif (tt > 0)\n&#123;\n\tnot empty\n&#125;else\n&#123;\n    empty\n&#125;\n 队列\n先进先出(FIFO)\n// hh 表示队头，tt表示队尾\nint q[N], hh = 0, tt = -1;\n\n// 向队尾插入一个数\nq[ ++ tt] = x;\n\n// 从队头弹出一个数\nhh ++ ;\n\n// 队头的值\nq[hh];\n\n// 判断队列是否为空，如果 hh &lt;= tt，则表示不为空\nif (hh &lt;= tt)\n&#123;\n\n&#125;\n循环队列\n// hh 表示队头，tt表示队尾的后一个位置\nint q[N], hh = 0, tt = 0;\n\n// 向队尾插入一个数\nq[tt ++ ] = x;\nif (tt == N) tt = 0;\n\n// 从队头弹出一个数\nhh ++ ;\nif (hh == N) hh = 0;\n\n// 队头的值\nq[hh];\n\n// 判断队列是否为空，如果hh != tt，则表示不为空\nif (hh != tt)\n&#123;\n\n&#125;\n 单调栈\n题型：求给定序列每一个数左/右边离他最近的比他大/小的数\nint tt = 0;\nfor (int i = 1; i &lt;= n; i ++ )\n&#123;\n    while (tt &amp;&amp; check(stk[tt], i)) tt -- ;\n    stk[ ++ tt] = i;\n&#125;\n 单调队列\n题型：求滑动窗口的最大/小值\nint hh = 0, tt = -1;\nfor (int i = 0; i &lt; n; i ++ )\n&#123;\n    while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口\n    while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ;\n    q[ ++ tt] = i;\n&#125;\n KMP\n1.56\n","categories":["算法"],"tags":[]},{"title":"2023年中闲聊","url":"/2023%E5%B9%B4%E4%B8%AD%E9%97%B2%E8%81%8A/","content":"现在是2023年6月30日午夜时分\n环境工程的期末考陆陆续续已经考完了，秉承不挂就行的心态\n这学期参加的两个比赛（ACM校内选拔赛+ACM软件外包创新赛）都以失败告终\n还是自己太菜了\n暑假的计划是 考研数据结构 + ACwing算法基础课，准备传智杯、计算机挑战赛、蓝桥杯校内预选赛和CSP(Maybe?)\n还有点想学一点点深度学习 ，再看看有没有时间咯\n加油吧！\n","categories":["闲聊"],"tags":[]},{"title":"算法基础课基础算法1-3","url":"/basic-algorithm1.3/","content":" 算法基础课基础算法1-3\n 双指针算法\n\n两个序列，两个指针\n一个序列，两个指针\n\n结构\nfor(int i=0,j=0;i&lt;n;i++)&#123;\n    while(j&lt;i &amp;&amp; check(i,j)) j++;\n    //每道题具体的逻辑\n&#125;\n核心思想\n复杂度由O(n2)O(n^2)O(n2)优化到O(n)O(n)O(n)\n先想出朴素做法，寻找i与j之间的关系，进行双指针优化\n 位运算\n\nn的二进制表示中第k位数字是几\n\n（k从个位开始算0,1,2…）\n\n先把第k位移到最后一位n&gt;&gt;k\n看个位是几 x&amp;1\n\n​\tn&gt;&gt;k&amp;1\n\nlowbit(x)\n\n​\t树状数组基本操作，返回x的最后一位1\n​\tx&amp;(-x)\n​\t原理：-x=(~x+1)\n 离散化\n这里特指整数离散化\n将值域大，个数少的数组映射到0,1…n的自然数\n①数组中可能有重复元素，需要去重\n②如何求出xxx离散化后的值-&gt;二分\nC++模版\nvector&lt;int> alls; // 存储所有待离散化的值\nsort(alls.begin(), alls.end()); // 将所有值排序\nalls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素\n\n// 二分求出x对应的离散化的值\nint find(int x) // 找到第一个大于等于x的位置\n&#123;\n    int l = 0, r = alls.size() - 1;\n    while (l &lt; r)\n    &#123;\n        int mid = l + r >> 1;\n        if (alls[mid] >= x) r = mid;\n        else l = mid + 1;\n    &#125;\n    return r + 1; // 映射到1, 2, ...n\n&#125;\n由于Java中没有uniqueuniqueunique方法，其中排序与去重的具体实现如下\n// 去重 + 排序  \nList&lt;Integer> distinctSorterAlls = alls.stream().distinct().sorted()  .collect(Collectors.toList());  \n 区间合并\n\n\n按照区间左端点排序\n\n\n判断下一个区间与当前区间的关系\n\n相交\n\n更新右端点为两个区间的maxmaxmax\n\n\n不相交\n\n将当前区间更新为不相交的这个区间\n\n\n\n\n\n​\tC++模版\n// 将所有存在交集的区间合并\nvoid merge(vector&lt;PII> &amp;segs)\n&#123;\n    vector&lt;PII> res;\n\n    sort(segs.begin(), segs.end());\n\n    int st = -2e9, ed = -2e9;\n    for (auto seg : segs)\n        if (ed &lt; seg.first)\n        &#123;\n            if (st != -2e9) res.push_back(&#123;st, ed&#125;);\n            st = seg.first, ed = seg.second;\n        &#125;\n        else ed = max(ed, seg.second);\n\n    if (st != -2e9) res.push_back(&#123;st, ed&#125;);\n\n    segs = res;\n&#125;\n在Java中可以自定义类来实现PIIPIIPII\nclass Pair&lt;U, V> &#123;\n    public final U first;\n    public final V second;\n\n    private Pair(U first, V second) &#123;\n        this.first = first;\n        this.second = second;\n    &#125;\n\n    @Override\n    public boolean equals(Object o) &#123;\n        if (this == o) &#123;\n            return true;\n        &#125;\n\n        if (o == null || getClass() != o.getClass()) &#123;\n            return false;\n        &#125;\n\n        Pair&lt;?, ?> pair = (Pair&lt;?, ?>) o;\n\n        if (!first.equals(pair.first)) &#123;\n            return false;\n        &#125;\n        return second.equals(pair.second);\n    &#125;\n\n    @Override\n    public int hashCode() &#123;\n        return 31 * first.hashCode() + second.hashCode();\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return \"(\" + first + \", \" + second + \")\";\n    &#125;\n\n    public static &lt;U, V> Pair &lt;U, V> of(U a, V b) &#123;\n        return new Pair&lt;>(a, b);\n    &#125;\n&#125;\n也可以直接用int[]，用前两位数&#123;first,second&#125;代替PIIPIIPII\n","categories":["算法"],"tags":[]},{"title":"算法基础课基础算法1-2","url":"/basic-algorithm1.2/","content":" 算法基础课基础算法1-2\n 高精度运算\n使用BigIntegerBigIntegerBigInteger和BigDecimalBigDecimalBigDecimal类实现\n 前缀和与差分\n一对逆运算\n 一维前缀和\n设有一列数据a1,a2,...,an−1,an{a}_1,{a}_2,...,{a}_{n-1},{a}_na1​,a2​,...,an−1​,an​\n定义Si=a1+a2+...+ai{S}_i=a_1+a_2+...+a_iSi​=a1​+a2​+...+ai​\n一般下标从1开始，S0=0S_0=0S0​=0\nSiS_iSi​的初始化: Si=Si−1+aiS_i = S_{i-1}+a_iSi​=Si−1​+ai​\n作用\n快速地求出原数组中一段区间数的和\n对于区间[l,r][l,r][l,r]\n∑i=lrai=Sr−Sl−1\\sum_{i=l}^{r}a_i  = S_r-S_{l-1}∑i=lr​ai​=Sr​−Sl−1​\n 二维前缀和\n对于二维数组（矩阵）(a11a12...a1ja21a22...a2j............ai1ai2...aij)\\begin{pmatrix}\n  a_{11}&amp; a_{12} &amp; ... &amp; a_{1j}\\\\\n  a_{21}&amp; a_{22} &amp; ... &amp; a_{2j} \\\\\n  ...&amp; ... &amp; ... &amp; ...\\\\\n  a_{i1}&amp; a_{i2} &amp; ... &amp; a_{ij}\n\\end{pmatrix}⎝⎜⎜⎜⎛​a11​a21​...ai1​​a12​a22​...ai2​​............​a1j​a2j​...aij​​⎠⎟⎟⎟⎞​\nSijS_{ij}Sij​代表aija_{ij}aij​左上角的所有元素和\n\n\n对于点(i,j)(i,j)(i,j)，其二维前缀和SijS_{ij}Sij​的初始化\nSij=Si−1,j+Si,j−1−Si−1,j−1+ai,jS_{ij}=S_{i-1,j}+S_{i,j-1}-S_{i-1,j-1}+a_{i,j}Sij​=Si−1,j​+Si,j−1​−Si−1,j−1​+ai,j​\n\n\n设点(x1,y1)(x_1,y_1)(x1​,y1​)在(x2,y2)(x_2,y_2)(x2​,y2​)的左上角，则两点围成的矩形中所有元素和\nS=Sx2,y2−Sx2,y1−1−Sx1−1,y2+Sx1−1,y1−1S=S_{x_2,y_2}-S_{x_2,y_1-1}-S_{x_1-1,y_2}+S_{x_1-1,y_1-1}S=Sx2​,y2​​−Sx2​,y1​−1​−Sx1​−1,y2​​+Sx1​−1,y1​−1​\n\n\n 一维差分\n对一列数据a1,a2,a3,...,aia_1,a_2,a_3,...,a_ia1​,a2​,a3​,...,ai​\n构造b1,b2,b3,...,bib_1,b_2,b_3,...,b_ib1​,b2​,b3​,...,bi​使得ai=b1+b2+...+bia_i=b_1+b_2+...+b_iai​=b1​+b2​+...+bi​\n即aaa为bbb的前缀和，bbb就是aaa的差分\n{b1=a1b2=a2−a1b3=a3−a2......bn=an−an−1\\left\\{\\begin{matrix}\nb_1=a_1\\\\\nb_2=a_2-a_1\\\\\nb_3=a_3-a_2\\\\\n ......\\\\\nb_n=a_n-a_{n-1}\n\\end{matrix}\\right.⎩⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎧​b1​=a1​b2​=a2​−a1​b3​=a3​−a2​......bn​=an​−an−1​​\n作用\n若要把a1,a2,a3,...,aia_1,a_2,a_3,...,a_ia1​,a2​,a3​,...,ai​中[l,r][l,r][l,r]区间的aaa加ccc\n只需要使bl+=c,br+1−=cb_l+=c,b_{r+1}-=cbl​+=c,br+1​−=c\n模版\nimport java.util.Scanner;\n\npublic class Diff &#123;\n    public static void main(String[] args) &#123;\n\n        Scanner scanner = new Scanner(System.in);\n\n        // 给出n数组大小和k增加次数\n        int n = scanner.nextInt();\n        int k = scanner.nextInt();\n\n        // 搭建数组\n        int[] arr = new int[n+1];\n        int[] brr = new int[n+1];\n\n        // 为arr赋值\n        for (int i = 1; i &lt; n+1; i++) &#123;\n            arr[i] = scanner.nextInt();\n        &#125;\n\n        // 为brr赋值\n        for (int i = 1; i &lt; n+1; i++)&#123;\n            brr[i] = arr[i] - arr[i-1];\n        &#125;\n\n        while (k-- > 0)&#123;\n            // 我们为arr的[l,r]区间加上c\n            int l = scanner.nextInt();\n            int r = scanner.nextInt();\n            int c = scanner.nextInt();\n\n            brr[l] += c;\n            brr[r+1] -= c;\n        &#125;\n\n        // 计算输出结果即可（这里输出的需要是由b累计出来的a）\n        // 也可以使用注释代码，最后输出arr即可\n        for (int i = 1; i &lt; n+1; i++) &#123;\n            brr[i] += brr[i-1];\n            //arr[i] = brr[i]+arr[i-1];\n        &#125;\n\n        // 最后输出结果\n        for (int i = 1; i &lt; n+1; i++) &#123;\n            System.out.println(brr[i]);\n        &#125;\n\n    &#125;\n&#125;\n 二维差分\n原矩阵aija_{ij}aij​,差分矩阵bijb_{ij}bij​\nbx1,y1+=cb_{x1,y1}+=cbx1,y1​+=c\nbx2+1,y−=cb_{x2+1,y}-=cbx2+1,y​−=c\nbx1,y2+1−=cb_{x1,y2+1}-=cbx1,y2+1​−=c\nbx2+1,y2+1+=cb_{x2+1,y2+1}+=cbx2+1,y2+1​+=c\n","categories":["算法"],"tags":[]},{"title":"算法基础课基础算法1-1","url":"/basic-algorithm1.1/","content":" 算法基础课基础算法1-1\n 快速排序\n分治思想,时间复杂度$O(nlogn)-O(n^2) $\n期望时间复杂度O(nlogn)O(nlogn)O(nlogn)\n\n\n数组中找一个值xxx作为分界点（可以是arr[l]arr\\left [ l \\right ]arr[l] ,arr[r]arr\\left [ r \\right ]arr[r],arr[l+r2]arr\\left [ \\frac{l+r}{2} \\right ]arr[2l+r​] 等等…）\n\n\n调整区间，使得左边的区间所有数≤\\le≤x，右边区间所有数&gt;&gt;&gt;x\n\n定义两个指针分别在左右边界\niii不断右移，直到遇到arr[i]arr[i]arr[i] &gt;x&gt;x&gt;x，就停下\njjj不断左移，直到遇到arr[j]≤xarr[j]\\le xarr[j]≤x，就停下\n交换arr[i]arr[i]arr[i]与arr[j]arr[j]arr[j]\n\n\n\n递归处理左右区间\n\n\n模版\npublic static void quick_sort(int q[], int l, int r)&#123;\n    if (l >= r) return;\n    int i = l - 1, j = r + 1, x = q[l + r >> 1];\n    while (i &lt; j)&#123;\n        do i ++ ; while (q[i] &lt; x);\n        do j -- ; while (q[j] > x);\n        if (i &lt; j) &#123;\n            int t = q[i];\n            q[i] = q[j];\n            q[j] = t;           \n        &#125;\n    &#125;\n    quick_sort(q, l, j);\n    quick_sort(q, j + 1, r);\n&#125;\n 归并排序\n分治思想,O(nlogn)O(nlogn)O(nlogn)\n\n\n确定分界点 mid=l+r2mid = \\frac{l+r}{2}mid=2l+r​\n\n\n递归排序leftleftleft和rightrightright\n\n\n归并：合二为一\n\n双指针指向leftleftleft和rightrightright的第一个元素\n创建一个空数组resresres存放结果\n指针比较，如果left[i]&lt;right[j]left[i]&lt;right[j]left[i]&lt;right[j]，则把left[i]left[i]left[i]放入resresres，iii向后移动一位，继续比较\n如果left[i]=right[j]left[i]=right[j]left[i]=right[j]，则把left[i]left[i]left[i]放入resresres，以维持稳定\n\n\n\n模版\npublic static void merge_sort(int q[], int l, int r)&#123;\n    if (l >= r) return;\n    int mid = l + r >> 1;\n\n    merge_sort(q, l, mid);\n    merge_sort(q, mid + 1, r);\n\n    int k = 0, i = l, j = mid + 1;\n\n    while (i &lt;= mid &amp;&amp; j &lt;= r)\n        if (q[i] &lt; q[j]) tmp[k ++ ] = q[i ++ ];\n    else tmp[k ++ ] = q[j ++ ];\n\n    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];\n    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];\n\n    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];\n&#125;\n 整数二分\n提示信息\n\n题目保证有解\n单调性\n求最大值的最小化\n\n思路\n对于区间[l,r][l,r][l,r]，其中一部分满足条件check(x)=truecheck(x)=truecheck(x)=true，另一部分不满足\n\n对于寻找不满足区间的边界\n\nmid=l+r+12mid = \\frac{l+r+1}{2}mid=2l+r+1​\n若check(mid)=truecheck(mid)=truecheck(mid)=true 则说明边界值在[mid,r][mid,r][mid,r]\n更新语句为l=midl = midl=mid\n若check(mid)=falsecheck(mid)=falsecheck(mid)=false 则说明边界值在[l,mid−1][l,mid-1][l,mid−1]\n更新语句为r=mid−1r = mid-1r=mid−1\n\n对于寻找满足区间的边界\n\nmid=l+r2mid = \\frac{l+r}{2}mid=2l+r​\n若check(mid)=truecheck(mid)=truecheck(mid)=true 则说明边界值在[l,mid][l,mid][l,mid]\n更新语句为r=midr = midr=mid\n若check(mid)=falsecheck(mid)=falsecheck(mid)=false 则说明边界值在[mid+1,r][mid+1,r][mid+1,r]\n更新语句为l=mid+1l=mid+1l=mid+1\n模版\npublic static boolean check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质\n\n// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：\npublic static int bsearch_1(int l, int r)\n&#123;\n    while (l &lt; r)\n    &#123;\n        int mid = l + r >> 1;\n        if (check(mid)) r = mid;    // check()判断mid是否满足性质\n        else l = mid + 1;\n    &#125;\n    return l;\n&#125;\n// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：\npublic static int bsearch_2(int l, int r)\n&#123;\n    while (l &lt; r)\n    &#123;\n        int mid = l + r + 1 >> 1;\n        if (check(mid)) l = mid;\n        else r = mid - 1;\n    &#125;\n    return l;\n&#125;\n如果l=midl=midl=mid ，最开始的midmidmid就要补上+1+1+1\n题目参考\nACWing冶炼金属\n 浮点数二分\npublic static boolean check(double x) &#123;/* ... */&#125; // 检查x是否满足某种性质\n\ndouble bsearch_3(double l, double r)\n&#123;\n    final double eps = 1e-6;   \n    // eps 表示精度，取决于题目对精度的要求\n    //比需要保留的位数多2\n    while (r - l > eps)\n    &#123;\n        double mid = (l + r) / 2;\n        if (check(mid)) r = mid;\n        else l = mid;\n    &#125;\n    return l;\n&#125;\n精度比需要保留的位数多-2次方\n可以把whilewhilewhile循环直接换成for100次\n","categories":["算法"],"tags":[]},{"title":"Git与github的基本使用","url":"/github/","content":"本文建立在读者已经拥有Github账号，本地安装了Git以及绑定了SSH密钥的情况下\n 基本使用\n\n首先在Github上新建一个仓库(Create a new repository)\n\n\n\n仓库名\n仓库的描述\n仓库类型，个人向一般都是public\n协议\n\n此外还可以选择是否添加README文件和.gitignore文件\n前者可以描述项目的主要内容，后者用于对文件的过滤\n至此，一个远程的仓库就创建好了\n\n实现本地代码和仓库代码同步\n\n当你创建好仓库后，你可以选择下面的方式进行代码托管\n\n在本地初始化git仓库后，绑定远程仓库\n\n首先我在桌面上创建一个demo文件夹，里面有一个hhh.txt文件\n在目录下执行git init操作\n\n此时文件夹多出了一个**.git**隐藏文件夹\n推荐常使用git status命令查看仓库状态\n此时我们执行这个命令\n\n大概的意思是，在master分支下，没有文件可以提交；此外还提醒我们hhh.txt文件没有上传\n此时我们执行git add hhh.txt\n如果接下来没有结果，那么恭喜你\n\n没有结果就是最好的结果\n\n此时再使用git status查看状态\n发现hhh.txt “to be committed” ，也就是这个文件已经放在了缓存区（防止你手滑上传了一些文件），你需要再次确认是否上传这个文件\n于是我们输入git commit hhh.txt -m &quot;第一次提交&quot;\n你可能会好奇 “-m” 和后面的**“第一次提交”**是个啥\n如果你有观摩过一些开源项目，会注意到这个\n\n也就是“更新说明”，你可以在commit的时候携带信息，说明这次更新的主要内容\n\n于是乎，文件hhh.txt就上传成功了\n接下来就是需要绑定远程仓库\n输入git remote add origin 仓库地址\n\n没有结果就是最好的结果\n然后我们将我们的文件push到远程仓库\ngit push -u origin 分支名\n\n打开我们的远程仓库，可以看见\n\n至此，这就是最基本的git使用。这是第一种方式\n\nclone到本地进行push\n\n获取到你的远程仓库地址\n\n输入git clone 仓库地址 可能会花费一点时间\n\n此时你clone的文件夹里面就会出现这个项目\n进入项目文件夹，添加文件xxx.txt\n你可以发现这个文件夹自带.git目录，所以你不需要去初始化和绑定远程仓库\ngit add xxx.txt\ngit commit xxx.txt -m &quot;嘻嘻嘻&quot;\ngit push origin [分支]  \n即可\n 在IDEA中使用git\n创建一个IDEA项目（我这里创建Springboot），勾选create git repository\n\n\nIDEA中可以一键进行commit/push操作\n\n绑定远程仓库地址\n\n进行push\n\n完成\n\n","categories":["教程"],"tags":[]},{"title":"HelloWorld","url":"/HelloWorld/","content":"把原来的一些杂乱的学习笔记都删了\n因为我觉得博客应该是记录一些自己的想法，而不是生抄别人的博客或者代码\n\n测试一下图片\npublic class Main&#123;\n    public static void init()&#123;\n        return;\n    &#125;\n&#125;\n测试一下代码块\n咕咕咕\n","categories":["闲聊"],"tags":[]}]