[{"title":"2023年中闲聊","url":"/2023%E5%B9%B4%E4%B8%AD%E9%97%B2%E8%81%8A/","content":"现在是2023年6月30日午夜时分\n环境工程的期末考陆陆续续已经考完了，秉承不挂就行的心态\n这学期参加的两个比赛（ACM校内选拔赛+ACM软件外包创新赛）都以失败告终\n还是自己太菜了\n暑假的计划是 考研数据结构 + ACwing算法基础课，准备传智杯、计算机挑战赛、蓝桥杯校内预选赛和CSP(Maybe?)\n还有点想学一点点深度学习 ，再看看有没有时间咯\n加油吧！\n","categories":["闲聊"],"tags":[]},{"title":"算法基础课基础算法(二)","url":"/basic-algorithm1.2/","content":" 算法基础课基础算法（二）\n 高精度运算\n使用BigIntegerBigIntegerBigInteger和BigDecimalBigDecimalBigDecimal类实现\n 前缀和与差分\n一对逆运算\n 一维前缀和\n设有一列数据a1,a2,...,an−1,an{a}_1,{a}_2,...,{a}_{n-1},{a}_na1​,a2​,...,an−1​,an​\n定义Si=a1+a2+...+ai{S}_i=a_1+a_2+...+a_iSi​=a1​+a2​+...+ai​\n一般下标从1开始，S0=0S_0=0S0​=0\nSiS_iSi​的初始化: Si=Si−1+aiS_i = S_{i-1}+a_iSi​=Si−1​+ai​\n作用\n快速地求出原数组中一段区间数的和\n对于区间[l,r][l,r][l,r]\n∑i=lrai=Sr−Sl−1\\sum_{i=l}^{r}a_i  = S_r-S_{l-1}∑i=lr​ai​=Sr​−Sl−1​\n 二维前缀和\n对于二维数组（矩阵）(a11a12...a1ja21a22...a2j............ai1ai2...aij)\\begin{pmatrix}\n  a_{11}&amp; a_{12} &amp; ... &amp; a_{1j}\\\\\n  a_{21}&amp; a_{22} &amp; ... &amp; a_{2j} \\\\\n  ...&amp; ... &amp; ... &amp; ...\\\\\n  a_{i1}&amp; a_{i2} &amp; ... &amp; a_{ij}\n\\end{pmatrix}⎝⎜⎜⎜⎛​a11​a21​...ai1​​a12​a22​...ai2​​............​a1j​a2j​...aij​​⎠⎟⎟⎟⎞​\nSijS_{ij}Sij​代表aija_{ij}aij​左上角的所有元素和\n\n\n对于点(i,j)(i,j)(i,j)，其二维前缀和SijS_{ij}Sij​的初始化\nSij=Si−1,j+Si,j−1−Si−1,j−1+ai,jS_{ij}=S_{i-1,j}+S_{i,j-1}-S_{i-1,j-1}+a_{i,j}Sij​=Si−1,j​+Si,j−1​−Si−1,j−1​+ai,j​\n\n\n设点(x1,y1)(x_1,y_1)(x1​,y1​)在(x2,y2)(x_2,y_2)(x2​,y2​)的左上角，则两点围成的矩形中所有元素和\nS=Sx2,y2−Sx2,y1−1−Sx1−1,y2+Sx1−1,y1−1S=S_{x_2,y_2}-S_{x_2,y_1-1}-S_{x_1-1,y_2}+S_{x_1-1,y_1-1}S=Sx2​,y2​​−Sx2​,y1​−1​−Sx1​−1,y2​​+Sx1​−1,y1​−1​\n\n\n 一维差分\n对一列数据a1,a2,a3,...,aia_1,a_2,a_3,...,a_ia1​,a2​,a3​,...,ai​\n构造b1,b2,b3,...,bib_1,b_2,b_3,...,b_ib1​,b2​,b3​,...,bi​使得ai=b1+b2+...+bia_i=b_1+b_2+...+b_iai​=b1​+b2​+...+bi​\n即aaa为bbb的前缀和，bbb就是aaa的差分\n{b1=a1b2=a2−a1b3=a3−a2......bn=an−an−1\\left\\{\\begin{matrix}\nb_1=a_1\\\\\nb_2=a_2-a_1\\\\\nb_3=a_3-a_2\\\\\n ......\\\\\nb_n=a_n-a_{n-1}\n\\end{matrix}\\right.⎩⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎧​b1​=a1​b2​=a2​−a1​b3​=a3​−a2​......bn​=an​−an−1​​\n作用\n若要把a1,a2,a3,...,aia_1,a_2,a_3,...,a_ia1​,a2​,a3​,...,ai​中[l,r][l,r][l,r]区间的aaa加ccc\n只需要使bl+=c,br+1−=cb_l+=c,b_{r+1}-=cbl​+=c,br+1​−=c\n模版\nimport java.util.Scanner;\n\npublic class Diff &#123;\n    public static void main(String[] args) &#123;\n\n        Scanner scanner = new Scanner(System.in);\n\n        // 给出n数组大小和k增加次数\n        int n = scanner.nextInt();\n        int k = scanner.nextInt();\n\n        // 搭建数组\n        int[] arr = new int[n+1];\n        int[] brr = new int[n+1];\n\n        // 为arr赋值\n        for (int i = 1; i &lt; n+1; i++) &#123;\n            arr[i] = scanner.nextInt();\n        &#125;\n\n        // 为brr赋值\n        for (int i = 1; i &lt; n+1; i++)&#123;\n            brr[i] = arr[i] - arr[i-1];\n        &#125;\n\n        while (k-- > 0)&#123;\n            // 我们为arr的[l,r]区间加上c\n            int l = scanner.nextInt();\n            int r = scanner.nextInt();\n            int c = scanner.nextInt();\n\n            brr[l] += c;\n            brr[r+1] -= c;\n        &#125;\n\n        // 计算输出结果即可（这里输出的需要是由b累计出来的a）\n        // 也可以使用注释代码，最后输出arr即可\n        for (int i = 1; i &lt; n+1; i++) &#123;\n            brr[i] += brr[i-1];\n            //arr[i] = brr[i]+arr[i-1];\n        &#125;\n\n        // 最后输出结果\n        for (int i = 1; i &lt; n+1; i++) &#123;\n            System.out.println(brr[i]);\n        &#125;\n\n    &#125;\n&#125;\n 二维差分\n原矩阵aija_{ij}aij​,差分矩阵bijb_{ij}bij​\nbx1,y1+=cb_{x1,y1}+=cbx1,y1​+=c\nbx2+1,y−=cb_{x2+1,y}-=cbx2+1,y​−=c\nbx1,y2+1−=cb_{x1,y2+1}-=cbx1,y2+1​−=c\nbx2+1,y2+1+=cb_{x2+1,y2+1}+=cbx2+1,y2+1​+=c\n","categories":["算法"],"tags":[]},{"title":"算法基础课基础算法(一)","url":"/basic-algorithm1.1/","content":" 算法基础课基础算法（一）\n 快速排序\n分治思想,$O(nlogn)-O(n²) $\n期望时间复杂度O(nlogn)O(nlogn)O(nlogn)\n\n\n数组中找一个值xxx作为分界点（可以是arr[l]arr\\left [ l \\right ]arr[l] ,arr[r]arr\\left [ r \\right ]arr[r],arr[l+r2]arr\\left [ \\frac{l+r}{2} \\right ]arr[2l+r​] 等等…）\n\n\n调整区间，使得左边的区间所有数≤\\le≤x，右边区间所有数&gt;&gt;&gt;x\n\n定义两个指针分别在左右边界\niii不断右移，直到遇到arr[i]arr[i]arr[i] &gt;x&gt;x&gt;x，就停下\njjj不断左移，直到遇到arr[j]≤xarr[j]\\le xarr[j]≤x，就停下\n交换arr[i]arr[i]arr[i]与arr[j]arr[j]arr[j]\n\n\n\n递归处理左右区间\n\n\n模版\npublic static void quick_sort(int q[], int l, int r)&#123;\n    if (l >= r) return;\n    int i = l - 1, j = r + 1, x = q[l + r >> 1];\n    while (i &lt; j)&#123;\n        do i ++ ; while (q[i] &lt; x);\n        do j -- ; while (q[j] > x);\n        if (i &lt; j) &#123;\n            int t = q[i];\n            q[i] = q[j];\n            q[j] = t;           \n        &#125;\n    &#125;\n    quick_sort(q, l, j);\n    quick_sort(q, j + 1, r);\n&#125;\n 归并排序\n分治思想,O(nlogn)O(nlogn)O(nlogn)\n\n\n确定分界点 mid=(l+r)/2mid = (l+r)/2mid=(l+r)/2\n\n\n递归排序leftleftleft和rightrightright\n\n\n归并：合二为一\n\n双指针指向leftleftleft和rightrightright的第一个元素\n创建一个空数组resresres存放结果\n指针比较，如果left[i]&lt;right[j]left[i]&lt;right[j]left[i]&lt;right[j]，则把left[i]left[i]left[i]放入resresres，iii向后移动一位，继续比较\n如果left[i]=right[j]left[i]=right[j]left[i]=right[j]，则把left[i]left[i]left[i]放入resresres，以维持稳定\n\n\n\n模版\npublic static void merge_sort(int q[], int l, int r)&#123;\n    if (l >= r) return;\n    int mid = l + r >> 1;\n\n    merge_sort(q, l, mid);\n    merge_sort(q, mid + 1, r);\n\n    int k = 0, i = l, j = mid + 1;\n\n    while (i &lt;= mid &amp;&amp; j &lt;= r)\n        if (q[i] &lt; q[j]) tmp[k ++ ] = q[i ++ ];\n    else tmp[k ++ ] = q[j ++ ];\n\n    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];\n    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];\n\n    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];\n&#125;\n 整数二分\n提示信息\n\n题目保证有解\n单调性\n求最大值的最小化\n\n思路\n对于区间[l,r][l,r][l,r]，其中一部分满足条件check(x)=truecheck(x)=truecheck(x)=true，另一部分不满足\n\n对于寻找不满足区间的边界\n\nmid=l+r+12mid = \\frac{l+r+1}{2}mid=2l+r+1​\n若check(mid)=truecheck(mid)=truecheck(mid)=true 则说明边界值在[mid,r][mid,r][mid,r]\n更新语句为l=midl = midl=mid\n若check(mid)=falsecheck(mid)=falsecheck(mid)=false 则说明边界值在[l,mid−1][l,mid-1][l,mid−1]\n更新语句为r=mid−1r = mid-1r=mid−1\n\n对于寻找满足区间的边界\n\nmid=l+r2mid = \\frac{l+r}{2}mid=2l+r​\n若check(mid)=truecheck(mid)=truecheck(mid)=true 则说明边界值在[l,mid][l,mid][l,mid]\n更新语句为r=midr = midr=mid\n若check(mid)=falsecheck(mid)=falsecheck(mid)=false 则说明边界值在[mid+1,r][mid+1,r][mid+1,r]\n更新语句为l=mid+1l=mid+1l=mid+1\n模版\npublic static boolean check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质\n\n// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：\npublic static int bsearch_1(int l, int r)\n&#123;\n    while (l &lt; r)\n    &#123;\n        int mid = l + r >> 1;\n        if (check(mid)) r = mid;    // check()判断mid是否满足性质\n        else l = mid + 1;\n    &#125;\n    return l;\n&#125;\n// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：\npublic static int bsearch_2(int l, int r)\n&#123;\n    while (l &lt; r)\n    &#123;\n        int mid = l + r + 1 >> 1;\n        if (check(mid)) l = mid;\n        else r = mid - 1;\n    &#125;\n    return l;\n&#125;\n如果l=midl=midl=mid ，最开始的midmidmid就要补上+1+1+1\n题目参考\nACWing冶炼金属\n 浮点数二分\npublic static boolean check(double x) &#123;/* ... */&#125; // 检查x是否满足某种性质\n\ndouble bsearch_3(double l, double r)\n&#123;\n    final double eps = 1e-6;   \n    // eps 表示精度，取决于题目对精度的要求\n    //比需要保留的位数多2\n    while (r - l > eps)\n    &#123;\n        double mid = (l + r) / 2;\n        if (check(mid)) r = mid;\n        else l = mid;\n    &#125;\n    return l;\n&#125;\n精度比需要保留的位数多-2次方\n可以把whilewhilewhile循环直接换成for100次\n","categories":["算法"],"tags":[]},{"title":"Git与github的基本使用","url":"/github/","content":"本文建立在读者已经拥有Github账号，本地安装了Git以及绑定了SSH密钥的情况下\n 基本使用\n\n首先在Github上新建一个仓库(Create a new repository)\n\n\n\n仓库名\n仓库的描述\n仓库类型，个人向一般都是public\n协议\n\n此外还可以选择是否添加README文件和.gitignore文件\n前者可以描述项目的主要内容，后者用于对文件的过滤\n至此，一个远程的仓库就创建好了\n\n实现本地代码和仓库代码同步\n\n当你创建好仓库后，你可以选择下面的方式进行代码托管\n\n在本地初始化git仓库后，绑定远程仓库\n\n首先我在桌面上创建一个demo文件夹，里面有一个hhh.txt文件\n在目录下执行git init操作\n\n此时文件夹多出了一个**.git**隐藏文件夹\n推荐常使用git status命令查看仓库状态\n此时我们执行这个命令\n\n大概的意思是，在master分支下，没有文件可以提交；此外还提醒我们hhh.txt文件没有上传\n此时我们执行git add hhh.txt\n如果接下来没有结果，那么恭喜你\n\n没有结果就是最好的结果\n\n此时再使用git status查看状态\n发现hhh.txt “to be committed” ，也就是这个文件已经放在了缓存区（防止你手滑上传了一些文件），你需要再次确认是否上传这个文件\n于是我们输入git commit hhh.txt -m &quot;第一次提交&quot;\n你可能会好奇 “-m” 和后面的**“第一次提交”**是个啥\n如果你有观摩过一些开源项目，会注意到这个\n\n也就是“更新说明”，你可以在commit的时候携带信息，说明这次更新的主要内容\n\n于是乎，文件hhh.txt就上传成功了\n接下来就是需要绑定远程仓库\n输入git remote add origin 仓库地址\n\n没有结果就是最好的结果\n然后我们将我们的文件push到远程仓库\ngit push -u origin 分支名\n\n打开我们的远程仓库，可以看见\n\n至此，这就是最基本的git使用。这是第一种方式\n\nclone到本地进行push\n\n获取到你的远程仓库地址\n\n输入git clone 仓库地址 可能会花费一点时间\n\n此时你clone的文件夹里面就会出现这个项目\n进入项目文件夹，添加文件xxx.txt\n你可以发现这个文件夹自带.git目录，所以你不需要去初始化和绑定远程仓库\ngit add xxx.txt\ngit commit xxx.txt -m &quot;嘻嘻嘻&quot;\ngit push origin [分支]  \n即可\n 在IDEA中使用git\n创建一个IDEA项目（我这里创建Springboot），勾选create git repository\n\n\nIDEA中可以一键进行commit/push操作\n\n绑定远程仓库地址\n\n进行push\n\n完成\n\n","categories":["教程"],"tags":[]},{"title":"HelloWorld","url":"/HelloWorld/","content":"把原来的一些杂乱的学习笔记都删了\n因为我觉得博客应该是记录一些自己的想法，而不是生抄别人的博客或者代码\n\n测试一下图片\npublic class Main&#123;\n    public static void init()&#123;\n        return;\n    &#125;\n&#125;\n测试一下代码块\n咕咕咕\n","categories":["闲聊"],"tags":[]}]